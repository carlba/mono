<html lang="en">
<head>
</head>

<body>
  <script type="module">
    import sdk from 'https://unpkg.com/@stackblitz/sdk@1/bundles/sdk.m.js';

    sdk.openProject(
      {
  "name": "playground",
  "template": "node",
  "files": {
    "nodemon.json": "{\n  \"execMap\": {\n    \"ts\": \"tsx\"\n  },\n  \"watch\": [\"src/**/*\", \".env\"]\n}\n",
    ".prettierrc": "{\n  \"arrowParens\": \"avoid\",\n  \"endOfLine\": \"auto\",\n  \"printWidth\": 100,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\",\n  \"proseWrap\": \"never\",\n  \"bracketSpacing\": true,\n  \"bracketSameLine\": true\n}\n",
    "tsconfig.json": "{\n  \"extends\": \"@tsconfig/node24/tsconfig.json\",\n  \"compilerOptions\": {\n\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"resolveJsonModule\": true,\n    \"moduleResolution\": \"nodenext\",\n    \"skipLibCheck\": true // Skip type checking of declaration files in node_modules\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\"]\n}\n",
    ".nvmrc": "v22\n",
    "package.json": "{\n  \"name\": \"playground\",\n  \"description\": \"Small test projects\",\n  \"version\": \"0.0.1\",\n  \"private\": false,\n  \"license\": \"UNLICENSED\",\n  \"type\": \"module\",\n  \"author\": \"carlba\",\n  \"homepage\": \"https://github.com/carlba/mono\",\n  \"bugs\": {\n    \"url\": \"https://github.com/carlba/mono\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.com:carlba/mono\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"start:dev\": \"nodemon -r dotenv/config -q src/index.ts\",\n    \"test\": \"vitest run\",\n    \"lint\": \"eslint .\",\n    \"format\": \"prettier --write .\",\n    \"format:check\": \"prettier --check .\",\n    \"dependency:update\": \"npx ncu -u -x eslint\",\n    \"test:watch\": \"vitest watch\",\n    \"test:coverage\": \"vitest run --coverage\"\n  },\n  \"devDependencies\": {\n    \"@tsconfig/node20\": \"^20.1.8\",\n    \"@tsconfig/node24\": \"^24.0.3\",\n    \"@types/jest\": \"^30.0.0\",\n    \"@types/js-yaml\": \"^4.0.9\",\n    \"@types/lodash\": \"^4.17.21\",\n    \"@types/node\": \"^25.0.3\",\n    \"dotenv\": \"^17.2.3\",\n    \"eslint\": \"^9.39.2\",\n    \"husky\": \"^9.1.7\",\n    \"jest\": \"^30.2.0\",\n    \"nodemon\": \"^3.1.11\",\n    \"npm-check-updates\": \"^19.3.1\",\n    \"prettier\": \"^3.7.4\",\n    \"ts-jest\": \"^29.4.6\",\n    \"tsx\": \"^4.21.0\",\n    \"typescript\": \"^5.9.3\",\n    \"typescript-eslint\": \"^8.52.0\",\n    \"vitest\": \"^4.0.16\"\n  },\n  \"dependencies\": {\n    \"@js-temporal/polyfill\": \"^0.5.1\",\n    \"js-yaml\": \"^4.1.1\",\n    \"lodash\": \"^4.17.21\"\n  }\n}\n",
    ".gitignore": "node_modules\ndist\n.env\n",
    "README.md": "# typescript-playground\n\nThe typescript-playground is a project space designed for experimenting, learning, and testing TypeScript code. It provides a flexible environment where you can try out new TypeScript features, explore various coding techniques, or simply practice your TypeScript programming skills.\n\nWhether you're a seasoned TypeScript developer looking to test a complex function, or a beginner trying to understand the basics, typescript-playground is the perfect place to play, learn, and grow your TypeScript knowledge.\n",
    "vitest.config.ts": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    // Environment\n    environment: 'node',\n    // Include below if you want code coverage\n    coverage: {\n      provider: 'v8', // or 'istanbul'\n      reporter: ['text', 'json', 'html'],\n    },\n    dir: 'src',\n  },\n});\n",
    "src/type-safe-filtering.ts": "interface Person {\n  name: string;\n  age: number;\n  status: 'active' | 'inactive';\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst persons: Person[] = [\n  {\n    name: 'Carl',\n    age: 37,\n    status: 'active',\n  },\n  {\n    name: 'Johanna',\n    age: 32,\n    status: 'active',\n  },\n  {\n    name: 'Tobias',\n    age: 27,\n    status: 'active',\n  },\n];\n\nArray.from(new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\n",
    "dist/range.js": "const range = (count) => Array.from({ length: count }, (v, i) => i);\nconsole.log(range(5));\nexport {};\n//# sourceMappingURL=range.js.map",
    "src/reverse-string.ts": "const str = 'testing';\n\nconst reverseString = (str: string) => {\n  let reversed = '';\n  for (let i = str.length - 1; i >= 0; i -= 1) {\n    reversed += str[i];\n  }\n  return reversed;\n};\n\nconst reverseStringPerformant = (str: string) => {\n  const reversed = [];\n  for (let i = str.length - 1; i >= 0; i -= 1) {\n    reversed.push(str[i]);\n  }\n  return reversed.join('');\n};\n\nconsole.log(reverseString(str));\nconsole.log(str.split('').reverse().join(''));\nconsole.log(reverseStringPerformant(str));\n\nconst onlyEqualValues = <T>(values: T[]): boolean => {\n  return new Set(values).size <= 1;\n};\n\nconsole.log(onlyEqualValues([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '1']));\n",
    "src/index.ts": "console.log('hello world');\n",
    "src/null.ts": "interface Todo {\n  id: string;\n  title: string;\n  description: string;\n}\n\nconst fetchTodo = (id: string): Todo | null => {\n  return {\n    id,\n    title: 'Clean room',\n    description: 'Clean the room before the guests arrive.',\n  };\n};\n\nconst todo = fetchTodo('1');\n\n// This will throw an error because the todo object can be null\n//@ts-expect-error Missing null check\ntodo.title;\n\n// This will not throw an error because optional chaining is used\ntodo?.description;\n",
    "src/range.ts": "const range = (count: number): number[] => Array.from({ length: count }, (v, i) => i);\n\nconsole.log(range(5));\n",
    "src/chunk.ts": "const chunk = <T>(arr: T[], size: number): T[][] =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (_, index) =>\n    arr.slice(index * size, index * size + size)\n  );\n\nconst persons = [\n  { name: 'Alice Johnson', age: 28, occupation: 'Software Engineer' },\n  { name: 'Bob Smith', age: 35, occupation: 'Teacher' },\n  { name: 'Carol Williams', age: 42, occupation: 'Doctor' },\n  { name: 'David Brown', age: 29, occupation: 'Graphic Designer' },\n  { name: 'Emma Davis', age: 31, occupation: 'Marketing Manager' },\n  { name: 'Frank Miller', age: 45, occupation: 'Chef' },\n  { name: 'Grace Wilson', age: 26, occupation: 'Nurse' },\n  { name: 'Henry Taylor', age: 38, occupation: 'Lawyer' },\n  { name: 'Ivy Anderson', age: 33, occupation: 'Data Scientist' },\n  { name: 'Jack Thompson', age: 27, occupation: 'Photographer' },\n];\n\nfor (const person of chunk(persons, 2)) {\n  console.log(person);\n}\n",
    "src/unions.ts": "type stringOrNumber = string | number;\n\n// Valid\nconst name: stringOrNumber = 'Carl';\nconst age: stringOrNumber = 25;\n\n// Invalid\n//@ts-expect-error Missing type check for boolean value.\nconst isOpen: stringOrNumber = true;\n\nconsole.log(isOpen, name, age);\n",
    "src/promise-race.ts": "async function main() {\n  const result = await Promise.race([\n    new Promise(resolve => {\n      setTimeout(() => resolve('First Promise'), 10);\n    }),\n    new Promise(resolve => {\n      setTimeout(() => resolve('Second Promise'), 5);\n    }),\n  ]);\n\n  console.log(result);\n}\n\nmain().catch(console.error);\n",
    "src/type-safe-pick.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { omit } from './type-safe-pick.js';\n\nimport { pick as lodashPick } from 'lodash';\n\ndescribe('type-safe-pick', () => {\n  it('should pick keys from object', () => {\n    const obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n    };\n\n    const picked = lodashPick(obj, ['a', 'c', 'nisse']);\n\n    expect(picked).toEqual({ a: 1, c: 3 });\n  });\n\n  it('should omit keys from object', () => {\n    const obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n    };\n\n    const omitted = omit(obj, ['b']);\n\n    expect(omitted).toEqual({ a: 1, c: 3 });\n  });\n});\n",
    "src/basename.ts": "import path from 'path';\n\nconst filename = '/text';\n\nconst test = filename.slice(0, filename.lastIndexOf('.'));\n\nconst test2 = path.basename(filename);\n\nconsole.log(test, test2);\n",
    "src/function-types.ts": "/**\n * A type that describes a function that takes a string and returns a number. These functions types\n * can be used to define generic properties of a function. This interface for instance is useful\n * for a function that takes a string as its argument and returns the length of the string.\n */\ntype functionInterface = (a: string) => number;\n\n/**\n * A function that takes a string and returns the length of the string.\n * @param a A string\n * @returns The length of the string\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringLength: functionInterface = (a: string) => a.length;\n",
    "src/timezone.ts": "import { Temporal } from '@js-temporal/polyfill';\n\n// https://tc39.es/proposal-temporal/docs/cookbook.html\n\nconsole.log(`✅ Current time in ISO 8601 is ${new Date().toISOString()}`);\nconsole.log(\n  `✅ Current time in ISO 8601 using Temporal ${Temporal.Now.plainDateTimeISO().toString()}`\n);\n\nconsole.log(`✅ Current time in epoch ${Temporal.Now.instant().epochMilliseconds}`);\n\nconst timeInMexicoCity = Temporal.ZonedDateTime.from('2025-01-30T09:00[Africa/Dar_es_Salaam]');\n\nconsole.log(\n  `✅ At 12:00 in CDMX it is ${timeInMexicoCity.withTimeZone('America/Mexico_City').toString()}`\n);\n",
    "dist/type-safe-pick.js.map": "{\"version\":3,\"file\":\"type-safe-pick.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/type-safe-pick.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,SAAS,GAAG,CAAiB,IAAO,EAAE,KAAmB,EAAa,EAAE,CAC5E,KAAK,CAAC,QAAQ,CAAC,IAAS,CAAC,CAAC;AAE5B,MAAM,UAAU,IAAI,CAAsC,GAAM,EAAE,IAAS;IACzE,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAC9B,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;QACX,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE,CAAC;YAC3B,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;QACtB,CAAC;QACD,OAAO,GAAG,CAAC;IACb,CAAC,EACD,EAAgB,CACjB,CAAC;IAEF,OAAO,YAAY,CAAC;AACtB,CAAC;AAED,MAAM,UAAU,IAAI,CAAsC,GAAM,EAAE,IAAS;IACzE,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAQ,CAAC;IAExC,OAAO,OAAO,CAAC,MAAM,CACnB,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;QACd,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE,CAAC;YAC1B,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;QACzB,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,EACD,EAAgB,CACjB,CAAC;AACJ,CAAC;AAED,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/type-safe-pick.spec.js": "import { describe, it, expect } from 'vitest';\nimport { omit } from './type-safe-pick.js';\nimport { pick as lodashPick } from 'lodash';\ndescribe('type-safe-pick', () => {\n    it('should pick keys from object', () => {\n        const obj = {\n            a: 1,\n            b: 2,\n            c: 3,\n        };\n        const picked = lodashPick(obj, ['a', 'c', 'nisse']);\n        expect(picked).toEqual({ a: 1, c: 3 });\n    });\n    it('should omit keys from object', () => {\n        const obj = {\n            a: 1,\n            b: 2,\n            c: 3,\n        };\n        const omitted = omit(obj, ['b']);\n        expect(omitted).toEqual({ a: 1, c: 3 });\n    });\n});\n//# sourceMappingURL=type-safe-pick.spec.js.map",
    "dist/basename.js": "import path from 'path';\nconst filename = '/text';\nconst test = filename.slice(0, filename.lastIndexOf('.'));\nconst test2 = path.basename(filename);\nconsole.log(test, test2);\n//# sourceMappingURL=basename.js.map",
    "dist/promise-race.js.map": "{\"version\":3,\"file\":\"promise-race.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/promise-race.ts\"],\"names\":[],\"mappings\":\"AAAA,KAAK,UAAU,IAAI;IACjB,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC;QAChC,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YACpB,UAAU,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC;QACjD,CAAC,CAAC;QACF,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YACpB,UAAU,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;QACjD,CAAC,CAAC;KACH,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACtB,CAAC;AAED,IAAI,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC\"}",
    "dist/launcher.js": "import * as readline from 'node:readline';\nimport { extname, join, parse } from 'node:path';\nimport { spawn } from 'node:child_process';\nimport { readdirSync } from 'node:fs';\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout });\nfunction main() {\n    const [, , devMode] = process.argv;\n    const isDevMode = devMode === '--dev';\n    const scriptsDir = __dirname;\n    const scripts = readdirSync(scriptsDir)\n        .filter(file => ['.ts', '.js'].includes(extname(file)) &&\n        !file.endsWith('.spec.ts') &&\n        !file.endsWith('.spec.js') &&\n        !file.endsWith('js.map'))\n        .map(file => join(scriptsDir, file));\n    scripts.forEach((name, index) => {\n        console.log(`${index + 1}: ${parse(name).name}`);\n    });\n    rl.question(`Which script do you want to launch? `, answer => {\n        const parsedAnswer = parseInt(answer, 10);\n        if (parsedAnswer < 0 || parsedAnswer > scripts.length || Number.isNaN(parsedAnswer)) {\n            console.error(`Invalid choice ${answer}`);\n            rl.close();\n        }\n        const child = spawn('npx', [\n            isDevMode ? 'nodemon' : 'tsx',\n            '-r',\n            'dotenv/config',\n            `${scripts[parseInt(answer, 10) - 1]}`,\n            ...(isDevMode ? ['-q'] : []),\n        ], {\n            stdio: 'inherit',\n        });\n        child.on('exit', signal => {\n            console.log('test', signal);\n            rl.close();\n            process.exit(signal);\n        });\n        process.on('exit', signal => {\n            console.log('test', signal);\n        });\n        process.on('SIGTERM', () => {\n            console.log('Main process received SIGTERM. Forwarding to child...');\n            child.kill('SIGTERM'); // Pass SIGTERM to child process\n        });\n    });\n}\nmain();\n//# sourceMappingURL=launcher.js.map",
    "dist/filter.js": "import lodash from 'lodash';\nexport var AclAction;\n(function (AclAction) {\n    AclAction[\"READ\"] = \"READ\";\n    AclAction[\"WRITE\"] = \"WRITE\";\n    AclAction[\"DELETE\"] = \"DELETE\";\n    AclAction[\"TRAVERSE\"] = \"TRAVERSE\";\n})(AclAction || (AclAction = {}));\nconst acls = [\n    { actions: [AclAction.READ, AclAction.WRITE, AclAction.DELETE, AclAction.TRAVERSE] },\n    { actions: [AclAction.TRAVERSE] },\n];\nconst filteredAcls = acls\n    .filter(acl => !lodash.isEqual(acl.actions, ['TRAVERSE']))\n    .map(acl => acl.actions);\nconsole.log(filteredAcls);\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst generateWhereInput = (whereInput) => {\n    Object.entries(whereInput).forEach(([key, value]) => {\n        console.log(key, value);\n    });\n};\n//# sourceMappingURL=filter.js.map",
    "dist/type-safe-pick.spec.js.map": "{\"version\":3,\"file\":\"type-safe-pick.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/type-safe-pick.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,IAAI,EAAE,MAAM,qBAAqB,CAAC;AAE3C,OAAO,EAAE,IAAI,IAAI,UAAU,EAAE,MAAM,QAAQ,CAAC;AAE5C,QAAQ,CAAC,gBAAgB,EAAE,GAAG,EAAE;IAC9B,EAAE,CAAC,8BAA8B,EAAE,GAAG,EAAE;QACtC,MAAM,GAAG,GAAG;YACV,CAAC,EAAE,CAAC;YACJ,CAAC,EAAE,CAAC;YACJ,CAAC,EAAE,CAAC;SACL,CAAC;QAEF,MAAM,MAAM,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;QAEpD,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8BAA8B,EAAE,GAAG,EAAE;QACtC,MAAM,GAAG,GAAG;YACV,CAAC,EAAE,CAAC;YACJ,CAAC,EAAE,CAAC;YACJ,CAAC,EAAE,CAAC;SACL,CAAC;QAEF,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;QAEjC,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC1C,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/unions.js": "// Valid\nconst name = 'Carl';\nconst age = 25;\n// Invalid\n//@ts-expect-error Missing type check for boolean value.\nconst isOpen = true;\nconsole.log(isOpen, name, age);\nexport {};\n//# sourceMappingURL=unions.js.map",
    "dist/promise-race.js": "async function main() {\n    const result = await Promise.race([\n        new Promise(resolve => {\n            setTimeout(() => resolve('First Promise'), 10);\n        }),\n        new Promise(resolve => {\n            setTimeout(() => resolve('Second Promise'), 5);\n        }),\n    ]);\n    console.log(result);\n}\nmain().catch(console.error);\nexport {};\n//# sourceMappingURL=promise-race.js.map",
    "dist/chunk.js.map": "{\"version\":3,\"file\":\"chunk.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/chunk.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,KAAK,GAAG,CAAI,GAAQ,EAAE,IAAY,EAAS,EAAE,CACjD,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAChE,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,IAAI,GAAG,IAAI,CAAC,CAC7C,CAAC;AAEJ,MAAM,OAAO,GAAG;IACd,EAAE,IAAI,EAAE,eAAe,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,mBAAmB,EAAE;IACnE,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,SAAS,EAAE;IACrD,EAAE,IAAI,EAAE,gBAAgB,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,QAAQ,EAAE;IACzD,EAAE,IAAI,EAAE,aAAa,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,kBAAkB,EAAE;IAChE,EAAE,IAAI,EAAE,YAAY,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,mBAAmB,EAAE;IAChE,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,MAAM,EAAE;IACrD,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,OAAO,EAAE;IACtD,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,QAAQ,EAAE;IACvD,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,gBAAgB,EAAE;IAC/D,EAAE,IAAI,EAAE,eAAe,EAAE,GAAG,EAAE,EAAE,EAAE,UAAU,EAAE,cAAc,EAAE;CAC/D,CAAC;AAEF,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC;IACvC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACtB,CAAC\"}",
    "dist/launcher.js.map": "{\"version\":3,\"file\":\"launcher.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/launcher.ts\"],\"names\":[],\"mappings\":\"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\"}",
    "dist/index.js.map": "{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/index.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AACzC,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,MAAM,IAAI,CAAC;AAC7C,OAAO,IAAI,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,MAAM,CAAC;AAE/C,MAAM,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAEnC,MAAM,OAAO,GAAG,SAAS,CAAC;AAE1B,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC;AAE9C,IAAI,CAAC,UAAU,EAAE,CAAC;IAChB,OAAO,CAAC,KAAK,CAAC,sCAAsC,CAAC,CAAC;IACtD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC;AAED,SAAS,iBAAiB,CAAC,IAAY,EAAE,OAAe;IACtD,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;IAE/D,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,MAAM,CAAgB,CAAC,GAAG,EAAE,SAAS,EAAE,EAAE;QAC7D,IAAI,GAAG;YAAE,OAAO,GAAG,CAAC;QACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,cAAc,GAAG,SAAS,CAAC,CAAC;QAChE,OAAO,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC;IAChD,CAAC,EAAE,IAAI,CAAC,CAAC;AACX,CAAC;AAED,MAAM,kBAAkB,GAAG,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;AAClE,MAAM,qBAAqB,GAAG,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AAE3E,OAAO,CAAC,GAAG,CAAC,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,CAAC,CAAC;AAE3D,IAAI,CAAC,kBAAkB,EAAE,CAAC;IACxB,OAAO,CAAC,GAAG,CAAC,cAAc,UAAU,oBAAoB,CAAC,CAAC;IAC1D,OAAO,CAAC,GAAG,CACT,eAAe,WAAW,CAAC,OAAO,CAAC;SAChC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC9D,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAChD,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;SACtD,IAAI,CAAC,IAAI,CAAC,EAAE,CAChB,CAAC;IACF,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC;AAED,IAAI,CAAC;IACH,QAAQ,CAAC,OAAO,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,IAAI,kBAAkB,EAAE,EAAE,EAAE,KAAK,EAAE,SAAS,EAAE,CAAC,CAAC;AAC/F,CAAC;AAAC,OAAO,KAAK,EAAE,CAAC;IACf,IAAI,KAAK,YAAY,KAAK,EAAE,CAAC;QAC3B,IAAI,QAAQ,IAAI,KAAK,EAAE,CAAC;YACtB,OAAO,CAAC,IAAI,CAAC,0BAA0B,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QACjE,CAAC;IACH,CAAC;AACH,CAAC\"}",
    "dist/type-safe-pick.js": "const isInArray = (item, array) => array.includes(item);\nexport function pick(obj, keys) {\n    const pickedObject = keys.reduce((acc, key) => {\n        if (obj[key] !== undefined) {\n            acc[key] = obj[key];\n        }\n        return acc;\n    }, {});\n    return pickedObject;\n}\nexport function omit(obj, keys) {\n    const objKeys = Object.keys(obj);\n    return objKeys.reduce((result, key) => {\n        if (!isInArray(key, keys)) {\n            result[key] = obj[key];\n        }\n        return result;\n    }, {});\n}\nArray.from(new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\n//# sourceMappingURL=type-safe-pick.js.map",
    "dist/timezone.js.map": "{\"version\":3,\"file\":\"timezone.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/timezone.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AAEjD,uDAAuD;AAEvD,OAAO,CAAC,GAAG,CAAC,iCAAiC,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;AACzE,OAAO,CAAC,GAAG,CACT,6CAA6C,QAAQ,CAAC,GAAG,CAAC,gBAAgB,EAAE,CAAC,QAAQ,EAAE,EAAE,CAC1F,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,2BAA2B,QAAQ,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,iBAAiB,EAAE,CAAC,CAAC;AAEnF,MAAM,gBAAgB,GAAG,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;AAE/F,OAAO,CAAC,GAAG,CACT,4BAA4B,gBAAgB,CAAC,YAAY,CAAC,qBAAqB,CAAC,CAAC,QAAQ,EAAE,EAAE,CAC9F,CAAC\"}",
    "dist/function-types.js": "/**\n * A function that takes a string and returns the length of the string.\n * @param a A string\n * @returns The length of the string\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stringLength = (a) => a.length;\nexport {};\n//# sourceMappingURL=function-types.js.map",
    "dist/unions.js.map": "{\"version\":3,\"file\":\"unions.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/unions.ts\"],\"names\":[],\"mappings\":\"AAEA,QAAQ;AACR,MAAM,IAAI,GAAmB,MAAM,CAAC;AACpC,MAAM,GAAG,GAAmB,EAAE,CAAC;AAE/B,UAAU;AACV,wDAAwD;AACxD,MAAM,MAAM,GAAmB,IAAI,CAAC;AAEpC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC\"}",
    "dist/range.js.map": "{\"version\":3,\"file\":\"range.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/range.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,KAAK,GAAG,CAAC,KAAa,EAAY,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;AAEtF,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/testing.js": "const people = ['test'];\nconst [person] = people;\nconsole.log(person);\nexport {};\n//# sourceMappingURL=testing.js.map",
    "dist/timezone.js": "import { Temporal } from '@js-temporal/polyfill';\n// https://tc39.es/proposal-temporal/docs/cookbook.html\nconsole.log(`✅ Current time in ISO 8601 is ${new Date().toISOString()}`);\nconsole.log(`✅ Current time in ISO 8601 using Temporal ${Temporal.Now.plainDateTimeISO().toString()}`);\nconsole.log(`✅ Current time in epoch ${Temporal.Now.instant().epochMilliseconds}`);\nconst timeInMexicoCity = Temporal.ZonedDateTime.from('2025-01-30T09:00[Africa/Dar_es_Salaam]');\nconsole.log(`✅ At 12:00 in CDMX it is ${timeInMexicoCity.withTimeZone('America/Mexico_City').toString()}`);\n//# sourceMappingURL=timezone.js.map",
    "dist/basename.js.map": "{\"version\":3,\"file\":\"basename.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/basename.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,IAAI,MAAM,MAAM,CAAC;AAExB,MAAM,QAAQ,GAAG,OAAO,CAAC;AAEzB,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;AAE1D,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAEtC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC\"}",
    "dist/function-types.js.map": "{\"version\":3,\"file\":\"function-types.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/function-types.ts\"],\"names\":[],\"mappings\":\"AAOA;;;;GAIG;AACH,6DAA6D;AAC7D,MAAM,YAAY,GAAsB,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC\"}",
    "dist/index.js": "import { execSync } from 'child_process';\nimport { existsSync, readdirSync } from 'fs';\nimport path, { basename, extname } from 'path';\nconst scriptName = process.argv[2];\nconst dirname = __dirname;\nconst isDevMode = process.argv[3] === '--dev';\nif (!scriptName) {\n    console.error('Usage: npm run run-script -- script1');\n    process.exit(1);\n}\nfunction resolveScriptPath(name, basedir) {\n    const scriptBaseName = path.basename(name, path.extname(name));\n    return ['.ts', '.js'].reduce((acc, extension) => {\n        if (acc)\n            return acc;\n        const fullPath = path.join(basedir, scriptBaseName + extension);\n        return existsSync(fullPath) ? fullPath : null;\n    }, null);\n}\nconst absoluteScriptPath = resolveScriptPath(scriptName, dirname);\nconst absoluteCwdScriptPath = resolveScriptPath(scriptName, process.cwd());\nconsole.log({ absoluteCwdScriptPath, absoluteScriptPath });\nif (!absoluteScriptPath) {\n    console.log(`The script ${scriptName} does not exist \\n`);\n    console.log(`Try with: \\n${readdirSync(dirname)\n        .filter(filename => ['.ts', '.js'].includes(extname(filename)))\n        .filter(filename => !filename.includes('.spec.'))\n        .map(filename => basename(filename, extname(filename)))\n        .join('\\n')}`);\n    process.exit(1);\n}\ntry {\n    execSync(`npx ${isDevMode ? 'nodemon' : 'tsx'} ${absoluteScriptPath}`, { stdio: 'inherit' });\n}\ncatch (error) {\n    if (error instanceof Error) {\n        if ('signal' in error) {\n            console.warn(`Child process received ${String(error.signal)}`);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map",
    "dist/type-safe-filtering.js": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst persons = [\n    {\n        name: 'Carl',\n        age: 37,\n        status: 'active',\n    },\n    {\n        name: 'Johanna',\n        age: 32,\n        status: 'active',\n    },\n    {\n        name: 'Tobias',\n        age: 27,\n        status: 'active',\n    },\n];\nArray.from(new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\nexport {};\n//# sourceMappingURL=type-safe-filtering.js.map",
    "dist/type-safe-filtering.js.map": "{\"version\":3,\"file\":\"type-safe-filtering.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/type-safe-filtering.ts\"],\"names\":[],\"mappings\":\"AAMA,6DAA6D;AAC7D,MAAM,OAAO,GAAa;IACxB;QACE,IAAI,EAAE,MAAM;QACZ,GAAG,EAAE,EAAE;QACP,MAAM,EAAE,QAAQ;KACjB;IACD;QACE,IAAI,EAAE,SAAS;QACf,GAAG,EAAE,EAAE;QACP,MAAM,EAAE,QAAQ;KACjB;IACD;QACE,IAAI,EAAE,QAAQ;QACd,GAAG,EAAE,EAAE;QACP,MAAM,EAAE,QAAQ;KACjB;CACF,CAAC;AAEF,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/chunk.js": "const chunk = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (_, index) => arr.slice(index * size, index * size + size));\nconst persons = [\n    { name: 'Alice Johnson', age: 28, occupation: 'Software Engineer' },\n    { name: 'Bob Smith', age: 35, occupation: 'Teacher' },\n    { name: 'Carol Williams', age: 42, occupation: 'Doctor' },\n    { name: 'David Brown', age: 29, occupation: 'Graphic Designer' },\n    { name: 'Emma Davis', age: 31, occupation: 'Marketing Manager' },\n    { name: 'Frank Miller', age: 45, occupation: 'Chef' },\n    { name: 'Grace Wilson', age: 26, occupation: 'Nurse' },\n    { name: 'Henry Taylor', age: 38, occupation: 'Lawyer' },\n    { name: 'Ivy Anderson', age: 33, occupation: 'Data Scientist' },\n    { name: 'Jack Thompson', age: 27, occupation: 'Photographer' },\n];\nfor (const person of chunk(persons, 2)) {\n    console.log(person);\n}\nexport {};\n//# sourceMappingURL=chunk.js.map",
    "dist/testing.js.map": "{\"version\":3,\"file\":\"testing.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/testing.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,MAAM,GAAa,CAAC,MAAM,CAAC,CAAC;AAElC,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;AAExB,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC\"}",
    "dist/filter.js.map": "{\"version\":3,\"file\":\"filter.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/filter.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,MAAM,MAAM,QAAQ,CAAC;AAE5B,MAAM,CAAN,IAAY,SAKX;AALD,WAAY,SAAS;IACnB,0BAAa,CAAA;IACb,4BAAe,CAAA;IACf,8BAAiB,CAAA;IACjB,kCAAqB,CAAA;AACvB,CAAC,EALW,SAAS,KAAT,SAAS,QAKpB;AAED,MAAM,IAAI,GAAG;IACX,EAAE,OAAO,EAAE,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,QAAQ,CAAC,EAAE;IACpF,EAAE,OAAO,EAAE,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE;CAClC,CAAC;AAEF,MAAM,YAAY,GAAG,IAAI;KACtB,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;KACzD,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;AAE3B,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AAsB1B,6DAA6D;AAC7D,MAAM,kBAAkB,GAAG,CAAC,UAA2C,EAAE,EAAE;IACzE,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE;QAClD,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAC1B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC\"}",
    "dist/null.js": "const fetchTodo = (id) => {\n    return {\n        id,\n        title: 'Clean room',\n        description: 'Clean the room before the guests arrive.',\n    };\n};\nconst todo = fetchTodo('1');\n// This will throw an error because the todo object can be null\n//@ts-expect-error Missing null check\ntodo.title;\n// This will not throw an error because optional chaining is used\ntodo?.description;\nexport {};\n//# sourceMappingURL=null.js.map",
    "dist/null.js.map": "{\"version\":3,\"file\":\"null.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/null.ts\"],\"names\":[],\"mappings\":\"AAMA,MAAM,SAAS,GAAG,CAAC,EAAU,EAAe,EAAE;IAC5C,OAAO;QACL,EAAE;QACF,KAAK,EAAE,YAAY;QACnB,WAAW,EAAE,0CAA0C;KACxD,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,IAAI,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;AAE5B,+DAA+D;AAC/D,qCAAqC;AACrC,IAAI,CAAC,KAAK,CAAC;AAEX,iEAAiE;AACjE,IAAI,EAAE,WAAW,CAAC\"}",
    ".vscode/settings.json": "{\n  \"cSpell.words\": [\n    \"datastructures\"\n  ]\n}\n",
    "src/structy/longest-word.ts": "const longestWord = (sentence: string) => {\n  let longest = '';\n  const words = sentence.split(' ');\n\n  for (const word of words) {\n    if (word.length > longest.length) {\n      longest = word;\n    }\n  }\n  return longest;\n};\n\nconsole.info(longestWord('Testar att skriva lite gran'));\n",
    "src/structy/big-o-samples.ts": "/**\n * This will happen in constant time\n */\nconst greet = () => {\n  const greeting = 'hello';\n  console.log(greeting);\n};\n\ngreet();\n\n/**\n * This will also happen in constant time since object keys are hashes\n */\nconst existsInObject = (object: Record<string, string>, keyName: string) => {\n  return keyName in object;\n};\n\nconsole.log(existsInObject({ a: 'test' }, 'a'));\n\n/**\n * Time: O(n) Since the whole array could potentially require a pass to find a specific value.\n * Space: O(1)\n */\nconst existsInArray = <T>(arr: T[], value: T) => {\n  return arr.includes(value);\n};\nconsole.log(existsInArray(['test'], 'test'));\n\n/**\n * This will also happen in constant time O(n)\n */\nconst sumUsingFor = (arr: number[]) => {\n  let sum = 0;\n  for (const num of arr) {\n    sum += num;\n  }\n  return sum;\n};\nconsole.log(`Sum of array is ${sumUsingFor([1, 1, 1, 10, 10])}`);\n\n/** Time: O(n)\n *  Space: O(n) Since the range array grows with the size of n\n */\nconst range = (n: number) => {\n  const range = [];\n  for (let i = 1; i < n; i += 1) {\n    range.push(i); // Constant time operation will not add additional complexity\n  }\n  return range;\n};\n\nconsole.log('Range', range(10));\n\n/** Time: O(n^2) Since all the items of the array needs to be rearranged for each iteration of n\n *  Space: O(n) Since the range array grows with the size of n. It is not n^2 since it will not grow\n *              with the additional iterations made by the function.\n */\nconst reversedRange = (n: number) => {\n  const range = [];\n  for (let i = 1; i < n; i += 1) {\n    /**\n     * Insert value in front of an array. Since the value is inserted in the front of the array this\n     * will be an n operation. What really happens is that when the item is added in front all the\n     * other values has to be pushed one step in the array thus requiring an operation for each item\n     * in the array.\n     */\n    range.unshift(i);\n  }\n  return range;\n};\n\nconsole.log('Range', reversedRange(10));\n/**\n * Time: O(n^2) since the inner for loop will run for each other for loop\n * Space: O(1) since we are not creating any additional data structures\n */\nconst printPairs = (str: string) => {\n  for (const charI of str) {\n    for (const charJ of str) {\n      console.log(`${charI} ${charJ}`);\n    }\n  }\n  /** This will not add extra complexity since this is O(n) which is less complex than 0(n^2) */\n  for (const char of str) {\n    console.log(`${char}`);\n  }\n};\n\nprintPairs('test');\n",
    "src/structy/pair-sum.js": "const pairSum = (numbers, targetSum) => {\n  const previousNumbers = {};\n\n  for (let i = 0; i < numbers.length; i += 1) {\n    const number = numbers[i];\n    const previousIndex = previousNumbers[targetSum - number];\n    if (previousIndex !== undefined) {\n      return [i, previousIndex];\n    }\n    previousNumbers[number] = i;\n  }\n};\n\nconsole.log(pairSum([3, 2, 5, 4, 1], 8));\n",
    "src/structy/beginner-recursion/reverse-string.ts": "/**\n * Recursively sum all numbers in an array\n *\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const reverseString = (str: string): string => {\n  if (str.length === 0) {\n    return '';\n  }\n  return reverseString(str.slice(1)) + str.at(0);\n};\n",
    "src/structy/beginner-recursion/sum-of-lengths.ts": "/**\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const sumOfLengths = (strings: string[]): number => {\n  if (strings.length === 0) {\n    return 0;\n  }\n\n  return strings[0].length + sumOfLengths(strings.slice(1));\n};\n",
    "src/structy/beginner-recursion/generate-problems.ts": "import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport yaml from 'js-yaml';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\ninterface Problem {\n  name: string;\n  functionName: string;\n  description: string;\n  approachUrl: string;\n  walkthroughUrl: string;\n}\n\ninterface ProblemsData {\n  problems: Problem[];\n}\n\nconst __dirname = import.meta.dirname;\n\nasync function loadProblems(): Promise<ProblemsData> {\n  const filePath = path.join(__dirname, 'problems.yaml');\n  const fileContent = await fs.readFile(filePath, 'utf-8');\n  const data = yaml.load(fileContent) as ProblemsData;\n\n  if (!data.problems || !Array.isArray(data.problems)) {\n    throw new Error('Invalid problems.yaml structure: missing or invalid problems array');\n  }\n\n  return data;\n}\n\nfunction validateProblem(problem: Problem): boolean {\n  return !!(problem.name && problem.functionName && problem.description);\n}\n\nasync function getProblems(): Promise<Problem[]> {\n  const data = await loadProblems();\n  const validProblems = data.problems.filter(validateProblem);\n\n  if (validProblems.length !== data.problems.length) {\n    console.warn('Some problems failed validation and were skipped');\n  }\n\n  return validProblems;\n}\n\nasync function createProblemFileStructure(problem: Problem) {\n  const sourceFileContent = generateSourceFile(problem.description, problem.functionName);\n\n  const sourceFilePath = path.join(__dirname, `${problem.name}.ts`);\n  if (!existsSync(sourceFilePath)) {\n    fs.writeFile(sourceFilePath, sourceFileContent);\n  }\n\n  const specFileContent = '';\n\n  const specFilePath = path.join(__dirname, `${problem.name}.spec.ts`);\n  if (!existsSync(specFilePath)) {\n    fs.writeFile(specFilePath, specFileContent);\n  }\n\n  const solutionsFileContent = '';\n\n  const solutionsFilePath = path.join(__dirname, `${problem.name}-solution.js`);\n  if (!existsSync(solutionsFilePath)) {\n    fs.writeFile(solutionsFilePath, solutionsFileContent);\n  }\n\n  const approachFileName = `${problem.name}-approach.mp4`;\n  const approachFilePath = path.join(__dirname, approachFileName);\n  if (!existsSync(approachFilePath)) {\n    await downloadVideoFile(problem.approachUrl, approachFileName);\n  }\n\n  const walkthroughFileName = `${problem.name}-walkthrough.mp4`;\n  const walkthroughFilePath = path.join(__dirname, walkthroughFileName);\n  if (!existsSync(walkthroughFilePath)) {\n    await downloadVideoFile(problem.walkthroughUrl, walkthroughFileName);\n  }\n}\n\nconst sourceFileTemplate = `/**\n * {{description}}\n * \n * Time: O(?)\n * Space: O(?)\n */\nexport const {{functionName}} = (): void => {\n  // TODO: Implement\n};\n`;\n\nfunction generateSourceFile(description: string, functionName: string) {\n  return sourceFileTemplate\n    .replace('{{description}}', description)\n    .replace('{{functionName}}', functionName);\n}\n\nasync function downloadVideoFile(url: string, filename: string) {\n  try {\n    await execAsync(`yt-dlp -o \"${filename}\" \"${url}\"`);\n  } catch (error) {\n    if (error instanceof Error && 'stderr' in error) {\n      console.error('Error while downloading video', { error: error.stderr });\n    } else {\n      throw error;\n    }\n  }\n}\n\nasync function main() {\n  const problems = await getProblems();\n\n  const problemPromises = problems.map(problem => createProblemFileStructure(problem));\n\n  Promise.all(problemPromises);\n}\n\nawait main();\n",
    "src/structy/beginner-recursion/sum-numbers-recursive-solution.js": "const sumNumbersRecursive = numbers => {\n  if (numbers.length === 0) {\n    return 0;\n  }\n  return numbers[0] + sumNumbersRecursive(numbers.slice(1));\n};\n",
    "src/structy/beginner-recursion/reverse-string-solution.js": "const reverseString = s => {\n  if (s.length === 0) {\n    return '';\n  }\n\n  return reverseString(s.slice(1)) + s[0];\n};\n",
    "src/structy/beginner-recursion/factorial-sollutiion.js": "const factorial = n => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\nconsole.log(factorial(10));\n",
    "src/structy/beginner-recursion/sum-numbers-recursive.ts": "/**\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const sumNumbersRecursive = (numbers: number[]): number => {\n  // basecase\n  if (numbers.length === 0) {\n    return 0;\n  }\n  return numbers[0] + sumNumbersRecursive(numbers.slice(1));\n};\n\nconsole.log(sumNumbersRecursive([10])); //--> 10\nconsole.log(sumNumbersRecursive([10, 1, 1, 1, 20])); //--> 33\n",
    "src/structy/beginner-recursion/beginner-recursion-warm-up.ts": "const countDown = (start: number) => {\n  // Handle base case\n  if (start === 0) {\n    return;\n  }\n  // Recursion Step\n  return countDown(start - 1);\n};\n\ncountDown(5);\n",
    "src/structy/beginner-recursion/factorial.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { factorial } from './factorial.js';\n\ndescribe('factorial', () => {\n  it('test_00: returns 6 for 3!', () => {\n    const result = factorial(3);\n    expect(result).toBe(6);\n  });\n\n  it('test_01: returns 720 for 6!', () => {\n    const result = factorial(6);\n    expect(result).toBe(720);\n  });\n\n  it('test_02: returns large number for 18!', () => {\n    const result = factorial(18);\n    expect(result).toBe(6402373705728000);\n  });\n\n  it('test_03: returns 1 for 1!', () => {\n    const result = factorial(1);\n    expect(result).toBe(1);\n  });\n\n  it('test_04: returns large number for 13!', () => {\n    const result = factorial(13);\n    expect(result).toBe(6227020800);\n  });\n\n  it('test_05: returns 1 for 0! (base case)', () => {\n    const result = factorial(0);\n    expect(result).toBe(1);\n  });\n});\n",
    "src/structy/linked-list/reverse-list.ts": "export class Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nconst a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\n\na.next = b;\nb.next = c;\nc.next = d;\nd.next = e;\ne.next = f;\n\n/**\n * Reverse a linked list\n *\n * Time: O(?)\n * Space: O(?)\n */\nexport const reverseList = <T>(head: Node<T> | null): Node<T> | null => {\n  let current = head;\n  let previous = null;\n  while (current !== null) {\n    const next = current.next;\n    current.next = previous;\n    previous = current;\n    current = next;\n  }\n  return previous;\n};\n\nconsole.log(reverseList(a));\n",
    "src/structy/beginner-recursion/sum-of-lenghts.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { sumOfLengths } from './sum-of-lengths.js';\n\ndescribe('sumOfLengths', () => {\n  it('returns sum of lengths for mixed length strings', () => {\n    expect(sumOfLengths(['goat', 'cat', 'purple'])).toBe(13);\n  });\n\n  it('returns sum of lengths for varied strings', () => {\n    expect(sumOfLengths(['bike', 'at', 'pencils', 'phone'])).toBe(18);\n  });\n\n  it('returns 0 for empty array', () => {\n    expect(sumOfLengths([])).toBe(0);\n  });\n\n  it('returns 15 for array of strings with spaces', () => {\n    expect(sumOfLengths(['', ' ', '  ', '   ', '    ', '     '])).toBe(15);\n  });\n\n  it('returns sum of lengths for numeric strings', () => {\n    expect(sumOfLengths(['0', '313', '1234567890'])).toBe(14);\n  });\n});\n",
    "src/structy/linked-list/generate-problems.ts": "import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport yaml from 'js-yaml';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\ninterface Problem {\n  name: string;\n  functionName: string;\n  description: string;\n  approachUrl: string;\n  walkthroughUrl: string;\n}\n\ninterface ProblemsData {\n  problems: Problem[];\n}\n\nconst __dirname = import.meta.dirname;\n\nasync function loadProblems(): Promise<ProblemsData> {\n  const filePath = path.join(__dirname, 'problems.yaml');\n  const fileContent = await fs.readFile(filePath, 'utf-8');\n  const data = yaml.load(fileContent) as ProblemsData;\n\n  if (!data.problems || !Array.isArray(data.problems)) {\n    throw new Error('Invalid problems.yaml structure: missing or invalid problems array');\n  }\n\n  return data;\n}\n\nfunction validateProblem(problem: Problem): boolean {\n  return !!(problem.name && problem.functionName && problem.description);\n}\n\nasync function getProblems(): Promise<Problem[]> {\n  const data = await loadProblems();\n  const validProblems = data.problems.filter(validateProblem);\n\n  if (validProblems.length !== data.problems.length) {\n    console.warn('Some problems failed validation and were skipped');\n  }\n\n  return validProblems;\n}\n\nasync function createProblemFileStructure(problem: Problem) {\n  const sourceFileContent = generateSourceFile(problem.description, problem.functionName);\n\n  const sourceFilePath = path.join(__dirname, `${problem.name}.ts`);\n  if (!existsSync(sourceFilePath)) {\n    fs.writeFile(sourceFilePath, sourceFileContent);\n  }\n\n  const specFileContent = '';\n\n  const specFilePath = path.join(__dirname, `${problem.name}.spec.ts`);\n  if (!existsSync(specFilePath)) {\n    fs.writeFile(specFilePath, specFileContent);\n  }\n\n  const solutionsFileContent = '';\n\n  const solutionsFilePath = path.join(__dirname, `${problem.name}-solution.js`);\n  if (!existsSync(solutionsFilePath)) {\n    fs.writeFile(solutionsFilePath, solutionsFileContent);\n  }\n\n  const approachFileName = `${problem.name}-approach.mp4`;\n  const approachFilePath = path.join(__dirname, 'videos', approachFileName);\n  if (!existsSync(approachFilePath)) {\n    await downloadVideoFile(problem.approachUrl, approachFilePath);\n  }\n\n  const walkthroughFileName = `${problem.name}-walkthrough.mp4`;\n  const walkthroughFilePath = path.join(__dirname, 'videos', walkthroughFileName);\n  if (!existsSync(walkthroughFilePath)) {\n    await downloadVideoFile(problem.walkthroughUrl, walkthroughFilePath);\n  }\n}\n\nconst sourceFileTemplate = `/**\n * {{description}}\n * \n * Time: O(?)\n * Space: O(?)\n */\nexport const {{functionName}} = (): void => {\n  // TODO: Implement\n};\n`;\n\nfunction generateSourceFile(description: string, functionName: string) {\n  return sourceFileTemplate\n    .replace('{{description}}', description)\n    .replace('{{functionName}}', functionName);\n}\n\nasync function downloadVideoFile(url: string, filename: string) {\n  console.log(filename);\n  try {\n    await execAsync(`yt-dlp -o \"${filename}\" \"${url}\"`);\n  } catch (error) {\n    if (error instanceof Error && 'stderr' in error) {\n      console.error('Error while downloading video', { error: error.stderr });\n    } else {\n      throw error;\n    }\n  }\n}\n\nasync function main() {\n  const problems = await getProblems();\n\n  const problemPromises = problems.map(problem => createProblemFileStructure(problem));\n\n  Promise.all(problemPromises);\n}\n\nawait main();\n",
    "dist/structy/beginner-recursion/palindrome-recursive.js": "/**\n * Validate if a string is a palindrome\n *\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const palindrome = (str) => {\n    if (str.length <= 1) {\n        return true;\n    }\n    if (!(str.at(0) === str.at(-1))) {\n        return false;\n    }\n    return palindrome(str.slice(1, -1));\n};\n//# sourceMappingURL=palindrome-recursive.js.map",
    "dist/structy/beginner-recursion/reverse-string.js.map": "{\"version\":3,\"file\":\"reverse-string.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/reverse-string.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;GAKG;AACH,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,GAAW,EAAU,EAAE;IACnD,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACrB,OAAO,EAAE,CAAC;IACZ,CAAC;IACD,OAAO,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/sum-numbers-recursive.spec.js": "import { describe, it, expect } from 'vitest';\nimport { sumNumbersRecursive } from './sum-numbers-recursive.js';\ndescribe('sumNumbersRecursive', () => {\n    it('test_00: returns sum of positive numbers', () => {\n        const result = sumNumbersRecursive([5, 2, 9, 10]);\n        expect(result).toBe(26);\n    });\n    it('test_01: returns sum with alternating positive and negative', () => {\n        const result = sumNumbersRecursive([1, -1, 1, -1, 1, -1, 1]);\n        expect(result).toBe(1);\n    });\n    it('test_02: returns 0 for empty array', () => {\n        const result = sumNumbersRecursive([]);\n        expect(result).toBe(0);\n    });\n    it('test_03: returns sum with large number and zeros', () => {\n        const result = sumNumbersRecursive([1000, 0, 0, 0, 0, 0, 1]);\n        expect(result).toBe(1001);\n    });\n    it('test_04: returns sum of descending powers of 10', () => {\n        const result = sumNumbersRecursive([700, 70, 7]);\n        expect(result).toBe(777);\n    });\n    it('test_05: returns sum of negative numbers', () => {\n        const result = sumNumbersRecursive([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]);\n        expect(result).toBe(-55);\n    });\n    it('test_06: returns 0 for array of all zeros', () => {\n        const result = sumNumbersRecursive([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        expect(result).toBe(0);\n    });\n});\n//# sourceMappingURL=sum-numbers-recursive.spec.js.map",
    "dist/structy/beginner-recursion/generate-problems.js": "import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport yaml from 'js-yaml';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nconst execAsync = promisify(exec);\nconst __dirname = import.meta.dirname;\nasync function loadProblems() {\n    const filePath = path.join(__dirname, 'problems.yaml');\n    const fileContent = await fs.readFile(filePath, 'utf-8');\n    const data = yaml.load(fileContent);\n    if (!data.problems || !Array.isArray(data.problems)) {\n        throw new Error('Invalid problems.yaml structure: missing or invalid problems array');\n    }\n    return data;\n}\nfunction validateProblem(problem) {\n    return !!(problem.name && problem.functionName && problem.description);\n}\nasync function getProblems() {\n    const data = await loadProblems();\n    const validProblems = data.problems.filter(validateProblem);\n    if (validProblems.length !== data.problems.length) {\n        console.warn('Some problems failed validation and were skipped');\n    }\n    return validProblems;\n}\nasync function createProblemFileStructure(problem) {\n    const sourceFileContent = generateSourceFile(problem.description, problem.functionName);\n    const sourceFilePath = path.join(__dirname, `${problem.name}.ts`);\n    if (!existsSync(sourceFilePath)) {\n        fs.writeFile(sourceFilePath, sourceFileContent);\n    }\n    const specFileContent = '';\n    const specFilePath = path.join(__dirname, `${problem.name}.spec.ts`);\n    if (!existsSync(specFilePath)) {\n        fs.writeFile(specFilePath, specFileContent);\n    }\n    const solutionsFileContent = '';\n    const solutionsFilePath = path.join(__dirname, `${problem.name}-solution.js`);\n    if (!existsSync(solutionsFilePath)) {\n        fs.writeFile(solutionsFilePath, solutionsFileContent);\n    }\n    const approachFileName = `${problem.name}-approach.mp4`;\n    const approachFilePath = path.join(__dirname, approachFileName);\n    if (!existsSync(approachFilePath)) {\n        await downloadVideoFile(problem.approachUrl, approachFileName);\n    }\n    const walkthroughFileName = `${problem.name}-walkthrough.mp4`;\n    const walkthroughFilePath = path.join(__dirname, walkthroughFileName);\n    if (!existsSync(walkthroughFilePath)) {\n        await downloadVideoFile(problem.walkthroughUrl, walkthroughFileName);\n    }\n}\nconst sourceFileTemplate = `/**\n * {{description}}\n * \n * Time: O(?)\n * Space: O(?)\n */\nexport const {{functionName}} = (): void => {\n  // TODO: Implement\n};\n`;\nfunction generateSourceFile(description, functionName) {\n    return sourceFileTemplate\n        .replace('{{description}}', description)\n        .replace('{{functionName}}', functionName);\n}\nasync function downloadVideoFile(url, filename) {\n    try {\n        await execAsync(`yt-dlp -o \"${filename}\" \"${url}\"`);\n    }\n    catch (error) {\n        if (error instanceof Error && 'stderr' in error) {\n            console.error('Error while downloading video', { error: error.stderr });\n        }\n        else {\n            throw error;\n        }\n    }\n}\nasync function main() {\n    const problems = await getProblems();\n    const problemPromises = problems.map(problem => createProblemFileStructure(problem));\n    Promise.all(problemPromises);\n}\nawait main();\n//# sourceMappingURL=generate-problems.js.map",
    "dist/structy/beginner-recursion/palindrome-recursive.js.map": "{\"version\":3,\"file\":\"palindrome-recursive.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/palindrome-recursive.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;GAKG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,GAAW,EAAW,EAAE;IACjD,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;QACpB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/beginner-recursion-warm-up.js.map": "{\"version\":3,\"file\":\"beginner-recursion-warm-up.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/beginner-recursion-warm-up.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,SAAS,GAAG,CAAC,KAAa,EAAE,EAAE;IAClC,mBAAmB;IACnB,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;QAChB,OAAO;IACT,CAAC;IACD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IACnB,iBAAiB;IACjB,OAAO,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC;AAEF,SAAS,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/reverse-string.js": "/**\n * Recursively sum all numbers in an array\n *\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const reverseString = (str) => {\n    if (str.length === 0) {\n        return '';\n    }\n    return reverseString(str.slice(1)) + str.at(0);\n};\n//# sourceMappingURL=reverse-string.js.map",
    "dist/structy/beginner-recursion/fibonacci.spec.js": "import { describe, it, expect } from 'vitest';\nimport { fibonacci } from './fibonacci.js';\ndescribe('fibonacci', () => {\n    it('test_00: returns 0 for n=0', () => {\n        const result = fibonacci(0);\n        expect(result).toBe(0);\n    });\n    it('test_01: returns 1 for n=1', () => {\n        const result = fibonacci(1);\n        expect(result).toBe(1);\n    });\n    it('test_02: returns 1 for n=2', () => {\n        const result = fibonacci(2);\n        expect(result).toBe(1);\n    });\n    it('test_03: returns 2 for n=3', () => {\n        const result = fibonacci(3);\n        expect(result).toBe(2);\n    });\n    it('test_04: returns 3 for n=4', () => {\n        const result = fibonacci(4);\n        expect(result).toBe(3);\n    });\n    it('test_05: returns 5 for n=5', () => {\n        const result = fibonacci(5);\n        expect(result).toBe(5);\n    });\n    it('test_06: returns 21 for n=8', () => {\n        const result = fibonacci(8);\n        expect(result).toBe(21);\n    });\n});\n//# sourceMappingURL=fibonacci.spec.js.map",
    "dist/structy/beginner-recursion/sum-of-lengths.js": "/**\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const sumOfLengths = (strings) => {\n    if (strings.length === 0) {\n        return 0;\n    }\n    return strings[0].length + sumOfLengths(strings.slice(1));\n};\n//# sourceMappingURL=sum-of-lengths.js.map",
    "src/structy/linked-list/sum-list.spec.ts": "import { describe, it, expect } from 'vitest';\nimport { sumList } from './sum-list.js';\n\nclass Node {\n  val: number;\n  next: Node | null;\n\n  constructor(val: number) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\ndescribe('sumList', () => {\n  it('test_00: should sum a linked list with multiple nodes including negative values', () => {\n    const a = new Node(2);\n    const b = new Node(8);\n    const c = new Node(3);\n    const d = new Node(-1);\n    const e = new Node(7);\n\n    a.next = b;\n    b.next = c;\n    c.next = d;\n    d.next = e;\n\n    // 2 -> 8 -> 3 -> -1 -> 7\n    expect(sumList(a)).toBe(19);\n  });\n\n  it('test_01: should sum a two-node linked list', () => {\n    const x = new Node(38);\n    const y = new Node(4);\n\n    x.next = y;\n\n    // 38 -> 4\n    expect(sumList(x)).toBe(42);\n  });\n\n  it('test_02: should sum a single node linked list', () => {\n    const z = new Node(100);\n\n    // 100\n    expect(sumList(z)).toBe(100);\n  });\n\n  it('test_03: should return 0 for an empty list', () => {\n    // null\n    expect(sumList(null)).toBe(0);\n  });\n});\n",
    "dist/structy/beginner-recursion/fibonacci.js.map": "{\"version\":3,\"file\":\"fibonacci.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/fibonacci.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;GAKG;AACH,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,GAAW,EAAU,EAAE;IAC/C,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC;QACd,OAAO,CAAC,CAAC;IACX,CAAC;IAED,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC;QACd,OAAO,CAAC,CAAC;IACX,CAAC;IAED,OAAO,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/factorial.spec.js.map": "{\"version\":3,\"file\":\"factorial.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/factorial.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAE3C,QAAQ,CAAC,WAAW,EAAE,GAAG,EAAE;IACzB,EAAE,CAAC,2BAA2B,EAAE,GAAG,EAAE;QACnC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6BAA6B,EAAE,GAAG,EAAE;QACrC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;QAC/C,MAAM,MAAM,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC;QAC7B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACxC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,2BAA2B,EAAE,GAAG,EAAE;QACnC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;QAC/C,MAAM,MAAM,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC;QAC7B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAClC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;QAC/C,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/factorial.js.map": "{\"version\":3,\"file\":\"factorial.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/factorial.ts\"],\"names\":[],\"mappings\":\"AAAA;;;GAGG;AACH,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,GAAW,EAAU,EAAE;IAC/C,IAAI,GAAG,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC;QAC3B,OAAO,CAAC,CAAC;IACX,CAAC;IAED,OAAO,GAAG,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAClC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/fibonacci.js": "/**\n * Return the n-th number of the fibonacci sequence\n *\n * Time: O(2^n)\n * Space: O(n)\n */\nexport const fibonacci = (num) => {\n    if (num === 1) {\n        return 1;\n    }\n    if (num === 0) {\n        return 0;\n    }\n    return fibonacci(num - 1) + fibonacci(num - 2);\n};\n//# sourceMappingURL=fibonacci.js.map",
    "dist/structy/beginner-recursion/palindrome-recursive.spec.js.map": "{\"version\":3,\"file\":\"palindrome-recursive.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/palindrome-recursive.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,UAAU,EAAE,MAAM,2BAA2B,CAAC;AAEvD,QAAQ,CAAC,YAAY,EAAE,GAAG,EAAE;IAC1B,EAAE,CAAC,iCAAiC,EAAE,GAAG,EAAE;QACzC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;QACjC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,mCAAmC,EAAE,GAAG,EAAE;QAC3C,MAAM,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;QACnC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,mCAAmC,EAAE,GAAG,EAAE;QAC3C,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;QAClC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,mCAAmC,EAAE,GAAG,EAAE;QAC3C,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;QAClC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,qCAAqC,EAAE,GAAG,EAAE;QAC7C,MAAM,MAAM,GAAG,UAAU,CAAC,SAAS,CAAC,CAAC;QACrC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,qCAAqC,EAAE,GAAG,EAAE;QAC7C,MAAM,MAAM,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;QACpC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,wCAAwC,EAAE,GAAG,EAAE;QAChD,MAAM,MAAM,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC;QAC9B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/sum-of-lenghts.spec.js": "import { describe, it, expect } from 'vitest';\nimport { sumOfLengths } from './sum-of-lengths.js';\ndescribe('sumOfLengths', () => {\n    it('returns sum of lengths for mixed length strings', () => {\n        expect(sumOfLengths(['goat', 'cat', 'purple'])).toBe(13);\n    });\n    it('returns sum of lengths for varied strings', () => {\n        expect(sumOfLengths(['bike', 'at', 'pencils', 'phone'])).toBe(18);\n    });\n    it('returns 0 for empty array', () => {\n        expect(sumOfLengths([])).toBe(0);\n    });\n    it('returns 15 for array of strings with spaces', () => {\n        expect(sumOfLengths(['', ' ', '  ', '   ', '    ', '     '])).toBe(15);\n    });\n    it('returns sum of lengths for numeric strings', () => {\n        expect(sumOfLengths(['0', '313', '1234567890'])).toBe(14);\n    });\n});\n//# sourceMappingURL=sum-of-lenghts.spec.js.map",
    "dist/structy/beginner-recursion/fibonacci.spec.js.map": "{\"version\":3,\"file\":\"fibonacci.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/fibonacci.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAE3C,QAAQ,CAAC,WAAW,EAAE,GAAG,EAAE;IACzB,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACpC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACpC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACpC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACpC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACpC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACpC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6BAA6B,EAAE,GAAG,EAAE;QACrC,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC1B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/sum-of-lengths.js.map": "{\"version\":3,\"file\":\"sum-of-lengths.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/sum-of-lengths.ts\"],\"names\":[],\"mappings\":\"AAAA;;;GAGG;AACH,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,OAAiB,EAAU,EAAE;IACxD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACzB,OAAO,CAAC,CAAC;IACX,CAAC;IAED,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5D,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/sum-numbers-recursive.js": "/**\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const sumNumbersRecursive = (numbers) => {\n    // basecase\n    if (numbers.length === 0) {\n        return 0;\n    }\n    return numbers[0] + sumNumbersRecursive(numbers.slice(1));\n};\nconsole.log(sumNumbersRecursive([10])); //--> 10\nconsole.log(sumNumbersRecursive([10, 1, 1, 1, 20])); //--> 33\n//# sourceMappingURL=sum-numbers-recursive.js.map",
    "dist/structy/beginner-recursion/beginner-recursion-warm-up.js": "const countDown = (start) => {\n    // Handle base case\n    if (start === 0) {\n        return;\n    }\n    console.log(start);\n    // Recursion Step\n    return countDown(start - 1);\n};\ncountDown(5);\nexport {};\n//# sourceMappingURL=beginner-recursion-warm-up.js.map",
    "dist/structy/beginner-recursion/factorial.spec.js": "import { describe, it, expect } from 'vitest';\nimport { factorial } from './factorial.js';\ndescribe('factorial', () => {\n    it('test_00: returns 6 for 3!', () => {\n        const result = factorial(3);\n        expect(result).toBe(6);\n    });\n    it('test_01: returns 720 for 6!', () => {\n        const result = factorial(6);\n        expect(result).toBe(720);\n    });\n    it('test_02: returns large number for 18!', () => {\n        const result = factorial(18);\n        expect(result).toBe(6402373705728000);\n    });\n    it('test_03: returns 1 for 1!', () => {\n        const result = factorial(1);\n        expect(result).toBe(1);\n    });\n    it('test_04: returns large number for 13!', () => {\n        const result = factorial(13);\n        expect(result).toBe(6227020800);\n    });\n    it('test_05: returns 1 for 0! (base case)', () => {\n        const result = factorial(0);\n        expect(result).toBe(1);\n    });\n});\n//# sourceMappingURL=factorial.spec.js.map",
    "dist/structy/beginner-recursion/sum-numbers-recursive.spec.js.map": "{\"version\":3,\"file\":\"sum-numbers-recursive.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/sum-numbers-recursive.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,mBAAmB,EAAE,MAAM,4BAA4B,CAAC;AAEjE,QAAQ,CAAC,qBAAqB,EAAE,GAAG,EAAE;IACnC,EAAE,CAAC,0CAA0C,EAAE,GAAG,EAAE;QAClD,MAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;QAClD,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC1B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6DAA6D,EAAE,GAAG,EAAE;QACrE,MAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7D,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,oCAAoC,EAAE,GAAG,EAAE;QAC5C,MAAM,MAAM,GAAG,mBAAmB,CAAC,EAAE,CAAC,CAAC;QACvC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,kDAAkD,EAAE,GAAG,EAAE;QAC1D,MAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7D,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,iDAAiD,EAAE,GAAG,EAAE;QACzD,MAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACjD,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,0CAA0C,EAAE,GAAG,EAAE;QAClD,MAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9E,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,2CAA2C,EAAE,GAAG,EAAE;QACnD,MAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACjG,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/palindrome-recursive.spec.js": "import { describe, it, expect } from 'vitest';\nimport { palindrome } from './palindrome-recursive.js';\ndescribe('palindrome', () => {\n    it('test_00: returns true for \"pop\"', () => {\n        const result = palindrome('pop');\n        expect(result).toBe(true);\n    });\n    it('test_01: returns true for \"kayak\"', () => {\n        const result = palindrome('kayak');\n        expect(result).toBe(true);\n    });\n    it('test_02: returns false for \"pops\"', () => {\n        const result = palindrome('pops');\n        expect(result).toBe(false);\n    });\n    it('test_03: returns false for \"boot\"', () => {\n        const result = palindrome('boot');\n        expect(result).toBe(false);\n    });\n    it('test_04: returns true for \"rotator\"', () => {\n        const result = palindrome('rotator');\n        expect(result).toBe(true);\n    });\n    it('test_05: returns false for \"abcbca\"', () => {\n        const result = palindrome('abcbca');\n        expect(result).toBe(false);\n    });\n    it('test_06: returns true for empty string', () => {\n        const result = palindrome('');\n        expect(result).toBe(true);\n    });\n});\n//# sourceMappingURL=palindrome-recursive.spec.js.map",
    "src/structy/beginner-recursion/beginner-recursion-warm-up-sollution.js": "const countdown = n => {\n  if (n === 0) {\n    return;\n  }\n\n  console.log(n);\n  countdown(n - 1);\n};\n\ncountdown(5);\n",
    "src/structy/beginner-recursion/README.md": "# README\n\nRecursion is when a function calls itself rather than an iterative approach where a loop would be used. In most cases either a iterative approach of a recursive approach can be utilized to solve a problem. Personally I prefer to avoid recursion because I think that iterative solutions tend to be easier to reason about but there are exceptions to this rule.\n\n## Beginner Recursion Intro\n\nhttps://www.structy.net/problems/beginner-recursion-intro\n\n![image.png](./images/image-1.png)\n\n- A recursive function is a function that calls itself\n\n![image.png](./images/image-2.png)\n\n- It is important to have a stop condition that will prevent the recursion to continue forever. This concept is called a base case.\n- A recursive step is the countdown that makes the recursive function go further\n\n## Beginner Recursion Warmup\n\nhttps://www.structy.net/problems/beginner-recursion-warm-up-exercise\n\n[beginner-recursion-warm-up.ts](beginner-recursion-warm-up.ts)\n\n## Sum Numbers Recursive\n\nhttps://www.structy.net/problems/sum-numbers-recursive\n\nWatch the Approach video first!\n\nWrite a function sumNumbersRecursive that takes in an array of numbers and returns the sum of all the numbers in the array. All elements will be integers. Solve this recursively.\n\n### Approach\n\n![image.png](./images/image-3.png)\n\nStart by finding sub problems the smallest subproblem `[]=>0` is the base case.\n\n![image.png](./images/image-4.png)\n\n### What about Big-O notation\n\nAn initial complaint about this recursive solution is that Big-O notation is actually worse than the iterative version. This is true but it will become apparent later that recursion has other benefits in certain scenarios.\n\n#### Time\n\n![image.png](./images/image-5.png)\n\nThe Big-O notation for a recursive function basically equates to number of function calls made. For this function that is the number of items is the array + 1 for the basecase. So `O(n+1)` but the +1 is irrelevant in the grand schema so we remove it. For every function call we also need to slice the array which is also a `O(n)` linear operation. This means that the total time complexity is\n\n`O(n^)`\n\n#### Space Complexity\n\nFor recursive function each call is tracked in the call stack which will take up some memory. This means that the baseline will always be `O(n)`,\n\n![image.png](./images/image-6.png)\n\n## Factorial\n\nWrite a function, factorial, that takes in a number n and returns the factorial of that number. The factorial of n is the product of all the positive numbers less than or equal to n. You must solve this recursively.\n\n```\nFor example, the factorial of 6 is:\n6 * 5 * 4 * 3 * 2 * 1 = 720\n```\n\nYou can assume that n is a non-negative integer. Note that the factorial of 0 is defined to be 1 (wiki).\n\n### Approach\n\nThe factorial of a number can be derived by counting down from any given number and multiplying all numbers.\n\n```\nfactorial(5)\n5*4*3*2*1 = 120\n\n// Rules in math\nfactorial(1) = 1\nfactorial(0) = 0\n```\n\n#### Sub Problems\n\n![alt text|452x134](tech/Programming/structy/beginner-recursion/images/image.png)\n\n**Recursive Step**\n\n![alt text|470x128](image-7.png)\n\n## Sum of Lengths\n\nWrite a function sumOfLengths that takes in array of strings and returns the total length of the strings.\n\nYou must solve this recursively.\n\n### Approach\n\n![Breakdown the problem](./images/image-8.png)\n\n![Pseudo Code](./images/image-10.png)\n\nThe last one is as always the base case\n\n#### Big-O Notation\n\nTime: `O(n^2)` because we are going to have a function call for each array item and then slice the array as well\n\nSpace: `O(n^2)`\n\n## Reverse String\n\nhttps://www.structy.net/problems/premium/reverse-string-recursive\n\nWrite a function, reverseString, that takes in a string as an argument. The function should return the string with its characters in reverse order. You must do this recursively.\n\n### Approach\n\n![Sub Problems](image-11.png)\n\n## Palindrome\n\nWrite a function, palindrome, that takes in a string and returns a boolean indicating whether or not the string is the same forwards and backwards.\n\nYou must solve this recursively.\n\n### Approach\n\n![Sub Problems|390x216](image-12.png)\n\n1. We need to recurse through the string by comparing and removing the first and last character of the string if they are the same.\n2. If they are not the same false should be returned.\n\n## Fibonacci\n\nWrite a function, fibonacci, that takes in a number argument, n, and returns the n-th number of the Fibonacci sequence.\n\n- The 0-th number of the sequence is 0.\n- The 1-st number of the sequence is 1.\n- To generate further numbers of the sequence, calculate the sum of previous two numbers.\n\nYou must solve this recursively.\n\n### Approach\n\n![Fibonacci Recursive Step and Base Cases|478x372](./images/image-13.png)\n\n1. The recursive step for this is `fibonacci(n) -> fibonacci(n-1) + fibonacci(n-2)` which actually contains two recursive calls. It helps to visualize this with a recursion tree.\n\n   ![Recursion tree|528x323](./images/image-14.png)\n\n   For these kind of problems it makes sense to visualize the recursion in this way.\n\n### Time Complexity\n",
    "src/structy/beginner-recursion/reverse-string.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { reverseString } from './reverse-string.js';\n\ndescribe('reverseString', () => {\n  it('test_00: reverses \"hello\" to \"olleh\"', () => {\n    const result = reverseString('hello');\n    expect(result).toBe('olleh');\n  });\n\n  it('test_01: reverses \"abcdefg\" to \"gfedcba\"', () => {\n    const result = reverseString('abcdefg');\n    expect(result).toBe('gfedcba');\n  });\n\n  it('test_02: reverses \"stopwatch\" to \"hctawpots\"', () => {\n    const result = reverseString('stopwatch');\n    expect(result).toBe('hctawpots');\n  });\n\n  it('test_03: returns empty string for empty input', () => {\n    const result = reverseString('');\n    expect(result).toBe('');\n  });\n});\n",
    "src/structy/beginner-recursion/palindrome-recursive.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { palindrome } from './palindrome-recursive.js';\n\ndescribe('palindrome', () => {\n  it('test_00: returns true for \"pop\"', () => {\n    const result = palindrome('pop');\n    expect(result).toBe(true);\n  });\n\n  it('test_01: returns true for \"kayak\"', () => {\n    const result = palindrome('kayak');\n    expect(result).toBe(true);\n  });\n\n  it('test_02: returns false for \"pops\"', () => {\n    const result = palindrome('pops');\n    expect(result).toBe(false);\n  });\n\n  it('test_03: returns false for \"boot\"', () => {\n    const result = palindrome('boot');\n    expect(result).toBe(false);\n  });\n\n  it('test_04: returns true for \"rotator\"', () => {\n    const result = palindrome('rotator');\n    expect(result).toBe(true);\n  });\n\n  it('test_05: returns false for \"abcbca\"', () => {\n    const result = palindrome('abcbca');\n    expect(result).toBe(false);\n  });\n\n  it('test_06: returns true for empty string', () => {\n    const result = palindrome('');\n    expect(result).toBe(true);\n  });\n});\n",
    "src/structy/linked-list/linked-list-values.spec.ts": "import { describe, it, expect } from 'vitest';\n\nclass Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nimport { linkedListValues } from './linked-list-values.js';\n\ndescribe('linkedListValues', () => {\n  it('test_00: returns array of values for linked list a -> b -> c -> d', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n\n    a.next = b;\n    b.next = c;\n    c.next = d;\n\n    // a -> b -> c -> d\n    const result = linkedListValues(a);\n    expect(result).toEqual(['a', 'b', 'c', 'd']);\n  });\n\n  it('test_01: returns array of values for linked list x -> y', () => {\n    const x = new Node('x');\n    const y = new Node('y');\n\n    x.next = y;\n\n    // x -> y\n    const result = linkedListValues(x);\n    expect(result).toEqual(['x', 'y']);\n  });\n\n  it('test_02: returns array with single value for single node q', () => {\n    const q = new Node('q');\n\n    // q\n    const result = linkedListValues(q);\n    expect(result).toEqual(['q']);\n  });\n\n  it('test_03: returns empty array for null head', () => {\n    const result = linkedListValues(null);\n    expect(result).toEqual([]);\n  });\n});\n",
    "src/structy/beginner-recursion/problems.yaml": "problems:\n  # - name: sum-of-lengths\n  #   functionName: sumOfLengths\n  #   description: Sum the total length of all strings in an array\n\n  # - name: factorial\n  #   functionName: factorial\n  #   description: Calculate the factorial of a number\n\n  - name: reverse-string\n    functionName: reverseString\n    description: Recursively sum all numbers in an array\n    approachUrl: 'https://vod-adaptive-ak.vimeocdn.com/exp=1767551290~acl=%2F886ae598-72cc-4cbb-8ba2-f69359212997%2Fpsid%3Debcc0e94f63489fcd9c00d2e037fb75a2ee57f0996aabbbd291622c6115885d7%2F%2A~hmac=8d1b33fc683353511a5426ae2308d743b9c151fee26edc037c26a5c73af4c33e/886ae598-72cc-4cbb-8ba2-f69359212997/psid=ebcc0e94f63489fcd9c00d2e037fb75a2ee57f0996aabbbd291622c6115885d7/v2/playlist/av/primary/sub/151227448-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&locale=en&omit=opus&pathsig=8c953e4f~B22AvI2BxGRIH3Pw6385GIz-Cxg6nzSLee0bv4M-Xbc&qsr=1&r=dXM%3D&rh=2PgUlf&sf=fmp4'\n    walkthroughUrl: 'https://vod-adaptive-ak.vimeocdn.com/exp=1767551780~acl=%2Ff243f02f-2515-499b-a2a7-d1dcc2298042%2Fpsid%3D60758e743b7e134b9257707df31d14032868d2bb0ea91caabc1222ddc7c12961%2F%2A~hmac=8b7503e85295384abf6b0837da2cc7ecc696fe7f1f8a80f505b0b746f296bcb6/f243f02f-2515-499b-a2a7-d1dcc2298042/psid=60758e743b7e134b9257707df31d14032868d2bb0ea91caabc1222ddc7c12961/v2/playlist/av/primary/sub/151472722-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&locale=en&omit=opus&pathsig=8c953e4f~u9kFxmSGFpozRjMHMlvLyXNCBnb9f1bO2b_9pVaK460&qsr=1&r=dXM%3D&rh=395DPj&sf=fmp4'\n\n  - name: palindrome-recursive\n    functionName: palindrome\n    description: Validate if a string is a palindrome\n    approachUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1767553999~acl=%2F84aee48b-5427-455a-9dc2-b1916088db8b%2Fpsid%3De826f7b2d114a1dba2513bf7776f6e99a988bc04f87e02cf73dca2f25042eaca%2F%2A~hmac=a5647ee4a41bfe56e7fbf482bfe8415ac43397c0b312ae77321ba9bd17ec2571/84aee48b-5427-455a-9dc2-b1916088db8b/psid=e826f7b2d114a1dba2513bf7776f6e99a988bc04f87e02cf73dca2f25042eaca/v2/playlist/av/primary/sub/151227527-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&locale=en&omit=opus&pathsig=8c953e4f~SGTwazY0YU39EtVYoucGF76v1McD8p4Fr_RpIXM6-WI&qsr=1&r=dXM%3D&rh=pb7ou&sf=fmp4\n    walkthroughUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1767554024~acl=%2F06f4df39-8a02-46dc-929f-44737f3b6121%2Fpsid%3D3b2f76c27eb203949206b047c3ca1baa4a80295b47ac4b6e945ef8f6eb8b3318%2F%2A~hmac=16872ec79b88f2258470e8b595a8e8b905d64e1e3c974bc608d11c9fddb7eac4/06f4df39-8a02-46dc-929f-44737f3b6121/psid=3b2f76c27eb203949206b047c3ca1baa4a80295b47ac4b6e945ef8f6eb8b3318/v2/playlist/av/primary/sub/151472784-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&locale=en&omit=opus&pathsig=8c953e4f~xre9yliB0iNsPMrt0kA0PXQdRGpo4FQctJZwBfgkS7w&qsr=1&r=dXM%3D&rh=2XxP5k&sf=fmp4\n\n  - name: fibonacci\n    functionName: fibonacci\n    description: Return the n-th number of the fibonacci sequence\n    approachUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1767555709~acl=%2F33572b43-f9e2-4b6e-b343-b87fd7fce008%2Fpsid%3D1d92da199456b8309c63b1b783f29467f0013e6ab5fc316337f009147c994352%2F%2A~hmac=74d095244bee2e97c9b3c560cfb4223320b28a8699c1707a5a40be4d4bf5d55b/33572b43-f9e2-4b6e-b343-b87fd7fce008/psid=1d92da199456b8309c63b1b783f29467f0013e6ab5fc316337f009147c994352/v2/playlist/av/primary/sub/152022135-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&locale=en&omit=opus&pathsig=8c953e4f~kJEAcrIlR3VoH6fyw6kgaBSfxbCv1dJzl58W7-veo-0&qsr=1&r=dXM%3D&rh=34q71e&sf=fmp4\n    walkthroughUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1767555735~acl=%2F59003b82-538c-4a86-9625-3f849462eaea%2Fpsid%3D70d5705fc185ec16824a84a2583b47b18b62187011e47e9f03d6e5e216b63316%2F%2A~hmac=259e9bd3bd1d9f09eb3b257450cf84655587a01fbc7276da50f441b79bf7330f/59003b82-538c-4a86-9625-3f849462eaea/psid=70d5705fc185ec16824a84a2583b47b18b62187011e47e9f03d6e5e216b63316/v2/playlist/av/primary/sub/152096497-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&locale=en&omit=opus&pathsig=8c953e4f~Q2xi3zEhxFQmvyAKb3q-orEPbi8XtiA4cnHu-7Gud7E&qsr=1&r=dXM%3D&rh=3kdMkJ&sf=fmp4\n",
    "dist/structy/beginner-recursion/sum-of-lenghts.spec.js.map": "{\"version\":3,\"file\":\"sum-of-lenghts.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/sum-of-lenghts.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AAEnD,QAAQ,CAAC,cAAc,EAAE,GAAG,EAAE;IAC5B,EAAE,CAAC,iDAAiD,EAAE,GAAG,EAAE;QACzD,MAAM,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC3D,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,2CAA2C,EAAE,GAAG,EAAE;QACnD,MAAM,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,2BAA2B,EAAE,GAAG,EAAE;QACnC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACnC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6CAA6C,EAAE,GAAG,EAAE;QACrD,MAAM,CAAC,YAAY,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACzE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4CAA4C,EAAE,GAAG,EAAE;QACpD,MAAM,CAAC,YAAY,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC5D,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/structy/beginner-recursion/sum-numbers-recursive.js.map": "{\"version\":3,\"file\":\"sum-numbers-recursive.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/sum-numbers-recursive.ts\"],\"names\":[],\"mappings\":\"AAAA;;;GAGG;AACH,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,OAAiB,EAAU,EAAE;IAC/D,WAAW;IACX,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACzB,OAAO,CAAC,CAAC;IACX,CAAC;IACD,OAAO,OAAO,CAAC,CAAC,CAAC,GAAG,mBAAmB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5D,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ;AAChD,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ\"}",
    "dist/structy/beginner-recursion/generate-problems.js.map": "{\"version\":3,\"file\":\"generate-problems.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/generate-problems.ts\"],\"names\":[],\"mappings\":\"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\"}",
    "dist/structy/beginner-recursion/factorial.js": "/**\n * Time: O(n)\n * Space: O(n)\n */\nexport const factorial = (num) => {\n    if (num === 0 || num === 1) {\n        return 1;\n    }\n    return num * factorial(num - 1);\n};\n//# sourceMappingURL=factorial.js.map",
    "dist/structy/beginner-recursion/reverse-string.spec.js": "import { describe, it, expect } from 'vitest';\nimport { reverseString } from './reverse-string.js';\ndescribe('reverseString', () => {\n    it('test_00: reverses \"hello\" to \"olleh\"', () => {\n        const result = reverseString('hello');\n        expect(result).toBe('olleh');\n    });\n    it('test_01: reverses \"abcdefg\" to \"gfedcba\"', () => {\n        const result = reverseString('abcdefg');\n        expect(result).toBe('gfedcba');\n    });\n    it('test_02: reverses \"stopwatch\" to \"hctawpots\"', () => {\n        const result = reverseString('stopwatch');\n        expect(result).toBe('hctawpots');\n    });\n    it('test_03: returns empty string for empty input', () => {\n        const result = reverseString('');\n        expect(result).toBe('');\n    });\n});\n//# sourceMappingURL=reverse-string.spec.js.map",
    "dist/structy/beginner-recursion/reverse-string.spec.js.map": "{\"version\":3,\"file\":\"reverse-string.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/beginner-recursion/reverse-string.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AAEpD,QAAQ,CAAC,eAAe,EAAE,GAAG,EAAE;IAC7B,EAAE,CAAC,sCAAsC,EAAE,GAAG,EAAE;QAC9C,MAAM,MAAM,GAAG,aAAa,CAAC,OAAO,CAAC,CAAC;QACtC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC/B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,0CAA0C,EAAE,GAAG,EAAE;QAClD,MAAM,MAAM,GAAG,aAAa,CAAC,SAAS,CAAC,CAAC;QACxC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8CAA8C,EAAE,GAAG,EAAE;QACtD,MAAM,MAAM,GAAG,aAAa,CAAC,WAAW,CAAC,CAAC;QAC1C,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IACnC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,+CAA+C,EAAE,GAAG,EAAE;QACvD,MAAM,MAAM,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;QACjC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC1B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "src/structy/beginner-recursion/fibonacci-solution.js": "",
    "src/structy/linked-list/README.md": "# Linked List\n\n![linked-list-intro.mp4](linked-list-intro.mp4)\n\n![Linked List Including End Head and Tail](tech/Programming/structy/linked-list/image.png)\n\nA linked list comprises of a set of nodes(a datapoint) with a link to the next item. Usually this link is just referred to simply as the \"next\". The end of the linked list is usually indicated by `next` pointing to 'NULL'.\n\nThe first item of the linked list is called the `head`.\n\nThe last item in the linked list is referred to as `tail`\n\nReference implementation of a Linked List Node in Typescript\n\n```typescript\nclass Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n```\n\n## Difference Between Linked List and Array\n\nAn array is a fixed memory structure stored sequentially at one place in the memory whilst a linked list can be stored in many different positions linked by the next.\n\n![Inserting Node/Element in Array and Linked List](tech/Programming/structy/linked-list/image-1.png)\n\nTo insert an element in the middle of an array all the elements after the items needs to be shifted. This is an O(n) operation and can be time consuming for long arrays.\n\nFor a linked list it is as simple as changing the next of the item at index 1 to the new node and in turn change the next of that node to 3. This operation is `0(1)`\n\n## Traversing\n\n[linked-list-warm-up-exercise.ts](linked-list-warm-up-exercise.ts). There is a sample of both the iterative and Recursive approach in this file.\n\n## Iterative\n\nA linked list can be traversed by created a function that starts at the node and iterates through the linked list using the `node.next` property. A `current` variable is needed to keep track of which element we are currently at.\n\n## Recursive\n\nA linked list can also be traversed recursively by calling the function with `node.next` as the argument. The base case is when the current node is `null`, indicating the end of the list has been reached.\n\n**Key differences from iterative:**\n\n- No `current` variable needed - the function parameter tracks position\n- No loop - recursion handles the iteration\n- Each recursive call processes one node and delegates the rest to the next call\n- The base case (`head === null`) prevents infinite recursion\n\nThis pattern works for most linked list operations - the recursive call naturally moves through the list until reaching `null`.\n\n## Linked List Values\n\n[text](linked-list-values.ts)\n\nWrite a function, linkedListValues, that takes in the head of a linked list as an argument. The function should return an array containing all values of the nodes in the linked list.\n\nHey. This is our first linked list problem, so you should be liberal with watching the Approach and Walkthrough. Be productive! -AZ\n\n### Approach\n\n1. We should iterate through the linked list using the `node.next` property.\n2. An array needs be pushed to as we traverse the linked list.\n\n## Sum List\n\nWrite a function, sumList, that takes in the head of a linked list containing numbers as an argument. The function should return the total sum of all values in the linked list.\n\n### Approach\n\n![alt text](tech/Programming/structy/linked-list/image-2.png)\n\nThis should be pretty straightforward just iterate through the linked list and adding and adding the values into a sum.\n\n### Solution\n\n[text](sum-list.ts)\n\n## Linked List Find\n\nWrite a function, linkedListFind, that takes in the head of a linked list and a target value. The function should return a boolean indicating whether or not the linked list contains the target.\n\n### Approach and Solution\n\nSlight variation on the same concept this time we just iterate through the list and return true if the target value matches the current value.\n\n![alt text](./image-3.png)\n\n## Get Node Value\n\nWrite a function, getNodeValue, that takes in the head of a linked list and an index. The function should return the value of the linked list at the specified index.\n\nIf there is no node at the given index, then return null.\n\n## Reverse List\n\nWrite a function, reverseList, that takes in the head of a linked list as an argument. The function should reverse the order of the nodes in the linked list in-place and return the new head of the reversed linked list.\n\n![alt text](image-4.png)\n",
    "src/structy/beginner-recursion/factorial.ts": "/**\n * Time: O(n)\n * Space: O(n)\n */\nexport const factorial = (num: number): number => {\n  if (num === 0 || num === 1) {\n    return 1;\n  }\n\n  return num * factorial(num - 1);\n};\n",
    "src/structy/beginner-recursion/palindrome-recursive-solution.js": "",
    "src/structy/linked-list/reverse-list.spec.ts": "import { describe, it, expect } from 'vitest';\nimport { reverseList, Node } from './reverse-list.js';\n\ndescribe('reverseList', () => {\n  it('test_00 - should reverse a 6-node linked list', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n    const e = new Node('e');\n    const f = new Node('f');\n    a.next = b;\n    b.next = c;\n    c.next = d;\n    d.next = e;\n    e.next = f;\n    // a -> b -> c -> d -> e -> f\n    expect(reverseList(a)).toBe(f); // f -> e -> d -> c -> b -> a\n  });\n\n  it('test_01 - should reverse a 2-node linked list', () => {\n    const x = new Node('x');\n    const y = new Node('y');\n    x.next = y;\n    // x -> y\n    expect(reverseList(x)).toBe(y); // y -> x\n  });\n\n  it('test_02 - should handle a single node linked list', () => {\n    const p = new Node('p');\n    // p\n    expect(reverseList(p)).toBe(p); // p\n  });\n});\n",
    "src/structy/linked-list/linked-list-values.ts": "class Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n/**\n * Converts a linked list to an array\n *\n * Time: O(n)\n * Space: O(n)\n */\nexport const linkedListValues = <T>(head: Node<T> | null): T[] => {\n  let current = head;\n  const values: T[] = [];\n  while (current !== null) {\n    values.push(current.val);\n    current = current.next;\n  }\n  return values;\n};\n",
    "src/structy/beginner-recursion/sum-numbers-recursive.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { sumNumbersRecursive } from './sum-numbers-recursive.js';\n\ndescribe('sumNumbersRecursive', () => {\n  it('test_00: returns sum of positive numbers', () => {\n    const result = sumNumbersRecursive([5, 2, 9, 10]);\n    expect(result).toBe(26);\n  });\n\n  it('test_01: returns sum with alternating positive and negative', () => {\n    const result = sumNumbersRecursive([1, -1, 1, -1, 1, -1, 1]);\n    expect(result).toBe(1);\n  });\n\n  it('test_02: returns 0 for empty array', () => {\n    const result = sumNumbersRecursive([]);\n    expect(result).toBe(0);\n  });\n\n  it('test_03: returns sum with large number and zeros', () => {\n    const result = sumNumbersRecursive([1000, 0, 0, 0, 0, 0, 1]);\n    expect(result).toBe(1001);\n  });\n\n  it('test_04: returns sum of descending powers of 10', () => {\n    const result = sumNumbersRecursive([700, 70, 7]);\n    expect(result).toBe(777);\n  });\n\n  it('test_05: returns sum of negative numbers', () => {\n    const result = sumNumbersRecursive([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]);\n    expect(result).toBe(-55);\n  });\n\n  it('test_06: returns 0 for array of all zeros', () => {\n    const result = sumNumbersRecursive([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    expect(result).toBe(0);\n  });\n});\n",
    "src/structy/linked-list/sum-list.ts": "class Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n/**\n * Converts a linked list to an array\n *\n * Time: O(?)\n * Space: O(?)\n */\nexport const sumList = (head: Node<number> | null): number => {\n  let current: Node<number> | null = head;\n  let sum = 0;\n\n  while (current !== null) {\n    sum += current.val;\n    current = current.next;\n  }\n\n  return sum;\n};\n",
    "src/structy/beginner-recursion/palindrome-recursive.ts": "/**\n * Validate if a string is a palindrome\n *\n * Time: O(n^2)\n * Space: O(n^2)\n */\nexport const palindrome = (str: string): boolean => {\n  if (str.length <= 1) {\n    return true;\n  }\n\n  if (!(str.at(0) === str.at(-1))) {\n    return false;\n  }\n\n  return palindrome(str.slice(1, -1));\n};\n",
    "src/structy/linked-list/problems.yaml": "problems:\n  - name: linked-list-values\n    functionName: linkedListValues\n    description: Converts a linked list to an array\n    approachUrl: 'https://vod-adaptive-ak.vimeocdn.com/exp=1767569285~acl=%2F31c5eec4-8a55-4b82-ab7c-08c9b4237517%2Fpsid%3D9d2c8d5a9a222f176e194f7e7e00b5b68b518c7a3853d8f4b928f2901d2582eb%2F%2A~hmac=98b095b92eb201895a1d8d063631042950ee1cee51068aebede35ed0933fef7d/31c5eec4-8a55-4b82-ab7c-08c9b4237517/psid=9d2c8d5a9a222f176e194f7e7e00b5b68b518c7a3853d8f4b928f2901d2582eb/v2/playlist/av/primary/sub/35808115-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~woSuSO5W04J3dZiatH6IURKvVaK7kQ9newG-howtQUc&qsr=1&r=dXM%3D&rh=3djw9g&sf=fmp4'\n    walkthroughUrl: 'https://vod-adaptive-ak.vimeocdn.com/exp=1767569314~acl=%2F0e17a205-7ccb-418c-811f-4d0e0b2b3e2b%2Fpsid%3D482d1965cd1620bd51a31be109e1f6c41d74c2966d1453f41a803aa9863dc9e5%2F%2A~hmac=2c1d9831c9acc5fc64b73379c77a603f0bec3620ca4ee56ece940332c978975e/0e17a205-7ccb-418c-811f-4d0e0b2b3e2b/psid=482d1965cd1620bd51a31be109e1f6c41d74c2966d1453f41a803aa9863dc9e5/v2/playlist/av/primary/sub/35808478-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~hsZYN7VYffu___KZPzitmLeXmLhWf2DCBT4zfAY9Zmg&qsr=1&r=dXM%3D&rh=3hzM0x&sf=fmp4'\n  - name: sum-list\n    functionName: sumList\n    description: Converts a linked list to an array\n    approachUrl: 'https://vod-adaptive-ak.vimeocdn.com/exp=1768239965~acl=%2Fc6598629-28d6-402a-8297-b89fae6d8af1%2Fpsid%3D180bf540a97721f325ac025a6d90fb56ada7e5d4eed9820d8806de334a593f7c%2F%2A~hmac=c1da653092c6757328fcc16fcaf739d0188e5c1c95666df2c21f6e7445ed048f/c6598629-28d6-402a-8297-b89fae6d8af1/psid=180bf540a97721f325ac025a6d90fb56ada7e5d4eed9820d8806de334a593f7c/v2/playlist/av/primary/sub/35808952-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~kTfdPSF1bYQKxzDw4J8Nan4gLO7gFwpfYJz9f2zQTbs&qsr=1&r=dXM%3D&rh=4ylzEx&sf=fmp4'\n    walkthroughUrl: 'https://vod-adaptive-ak.vimeocdn.com/exp=1768239995~acl=%2F9be1a797-fbc8-4a6e-ac8d-cee49dd02b49%2Fpsid%3D9e5ad0abd10a3c46ba866fd907588fe75ba783cb8b9dd17f381f925fcc49e7d0%2F%2A~hmac=f75d2bbda040f9e9fbe861243a39bc6790c594a6ce12f3ff98404aace56d539c/9be1a797-fbc8-4a6e-ac8d-cee49dd02b49/psid=9e5ad0abd10a3c46ba866fd907588fe75ba783cb8b9dd17f381f925fcc49e7d0/v2/playlist/av/primary/sub/35809048-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~8-cv-QdlRuSV8ROEgL6BlJ3yKMgg9SRFEOJxZm6yvHQ&qsr=1&r=dXM%3D&rh=1QvgXs&sf=fmp4'\n  - name: linked-list-find\n    functionName: linkedListFind\n    description: Check if a certain value exists in a linked list\n    approachUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1768242058~acl=%2F45608dfc-a507-4e06-ad66-f3df03caf103%2Fpsid%3D83b07ae0f1a06e8a7b14f25c116abcf12e9741a075c40bb2a7e9d36d07e032a3%2F%2A~hmac=d5e6ed7c61b0df8f82d5d8d59742474192c0a50a1688b97d93e5d2fd7155c979/45608dfc-a507-4e06-ad66-f3df03caf103/psid=83b07ae0f1a06e8a7b14f25c116abcf12e9741a075c40bb2a7e9d36d07e032a3/v2/playlist/av/primary/sub/35809250-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~5SU6QDFFKsEMn2OeLcIv15bZIvE6AxHGVJjzbVP7YWE&qsr=1&r=dXM%3D&rh=3gtBjn&sf=fmp4\n    walkthroughUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1768242068~acl=%2F93ace849-e737-4a6d-a48e-a2dea8f25856%2Fpsid%3D30d08a4ad14026cf8846bc72c352bb19aa81dda3b850a9120b46fbf1a564bb97%2F%2A~hmac=3249a4c1b7e6eba45e1f6bb3965b7c137d12fe118d2a31979914a9a48c91f79c/93ace849-e737-4a6d-a48e-a2dea8f25856/psid=30d08a4ad14026cf8846bc72c352bb19aa81dda3b850a9120b46fbf1a564bb97/v2/playlist/av/primary/sub/35809302-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~JWGSJZVbpsWFgMmf26HXdT3oGkQRol2sLoi6naAQ3aI&qsr=1&r=dXM%3D&rh=44e6X3&sf=fmp4\n  - name: get-node-value\n    functionName: getNodeValue\n    description: Check if a certain value exists in a linked list\n    approachUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1768259625~acl=%2Faec5b05e-0cb9-4a60-85ff-f482c573a7fe%2Fpsid%3D82d2ad52b0959563dfe19c0ed704a32694c35508a3f3c18d3988c2312eb332df%2F%2A~hmac=18bc388f617368d0ada944460ff4d2bc9526ab147ba5dba5222852e823eb98f8/aec5b05e-0cb9-4a60-85ff-f482c573a7fe/psid=82d2ad52b0959563dfe19c0ed704a32694c35508a3f3c18d3988c2312eb332df/v2/playlist/av/primary/sub/35809412-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~H7vz3krZJ7iz2hmLaTzYbW-K6nhQ52Wd86cfU7l9xYk&qsr=1&r=dXM%3D&rh=2oDlki&sf=fmp4\n    walkthroughUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1768259625~acl=%2Faec5b05e-0cb9-4a60-85ff-f482c573a7fe%2Fpsid%3D82d2ad52b0959563dfe19c0ed704a32694c35508a3f3c18d3988c2312eb332df%2F%2A~hmac=18bc388f617368d0ada944460ff4d2bc9526ab147ba5dba5222852e823eb98f8/aec5b05e-0cb9-4a60-85ff-f482c573a7fe/psid=82d2ad52b0959563dfe19c0ed704a32694c35508a3f3c18d3988c2312eb332df/v2/playlist/av/primary/sub/35809412-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~H7vz3krZJ7iz2hmLaTzYbW-K6nhQ52Wd86cfU7l9xYk&qsr=1&r=dXM%3D&rh=2oDlki&sf=fmp4\n  - name: reverse-list\n    functionName: reverseList\n    description: Reverse a linked list\n    approachUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1768262038~acl=%2F45c40770-796e-42aa-8c00-a6e6a38c0d53%2Fpsid%3D807663f6657501ba2ebc33f5fc46a19e30587e9d5652ae51c6b5c17f4a66d804%2F%2A~hmac=7b3d108a467c490811be0dd4f4b7eb976132e9cf47146cc9eb66357de8f664fd/45c40770-796e-42aa-8c00-a6e6a38c0d53/psid=807663f6657501ba2ebc33f5fc46a19e30587e9d5652ae51c6b5c17f4a66d804/v2/playlist/av/primary/sub/35809838-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~YQCyMxo488oI_yP0hz6Dpz6PtAfRbk5XGc4ZeHphank&qsr=1&r=dXM%3D&rh=3QMFXN&sf=fmp4\n    walkthroughUrl: https://vod-adaptive-ak.vimeocdn.com/exp=1768262220~acl=%2F1d5e618d-7737-4178-bc2b-ea89b2410671%2Fpsid%3Db06d9731c202cb69d58aff85d0598c182b9fe47df15fa2870bf9197fc017f4ea%2F%2A~hmac=20588aa211e71482e8c5476cb88395e1bcbd325a073844f91eb3f73a91e5e8f6/1d5e618d-7737-4178-bc2b-ea89b2410671/psid=b06d9731c202cb69d58aff85d0598c182b9fe47df15fa2870bf9197fc017f4ea/v2/playlist/av/primary/sub/35810192-c-en-x-autogen/prot/cXNyPTE/playlist.m3u8?ext-subs=1&omit=opus&pathsig=8c953e4f~9QclhQrTh9aUmeUnQV25_II7lMW2NeM5Ek6rRuJy20s&qsr=1&r=dXM%3D&rh=4iE6St&sf=fmp4\n",
    "src/structy/linked-list/EXERCISES.md": "",
    "src/structy/beginner-recursion/fibonacci.ts": "/**\n * Return the n-th number of the fibonacci sequence\n *\n * Time: O(2^n)\n * Space: O(n)\n */\nexport const fibonacci = (num: number): number => {\n  if (num === 1) {\n    return 1;\n  }\n\n  if (num === 0) {\n    return 0;\n  }\n\n  return fibonacci(num - 1) + fibonacci(num - 2);\n};\n",
    "src/structy/beginner-recursion/fibonacci.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { fibonacci } from './fibonacci.js';\n\ndescribe('fibonacci', () => {\n  it('test_00: returns 0 for n=0', () => {\n    const result = fibonacci(0);\n    expect(result).toBe(0);\n  });\n\n  it('test_01: returns 1 for n=1', () => {\n    const result = fibonacci(1);\n    expect(result).toBe(1);\n  });\n\n  it('test_02: returns 1 for n=2', () => {\n    const result = fibonacci(2);\n    expect(result).toBe(1);\n  });\n\n  it('test_03: returns 2 for n=3', () => {\n    const result = fibonacci(3);\n    expect(result).toBe(2);\n  });\n\n  it('test_04: returns 3 for n=4', () => {\n    const result = fibonacci(4);\n    expect(result).toBe(3);\n  });\n\n  it('test_05: returns 5 for n=5', () => {\n    const result = fibonacci(5);\n    expect(result).toBe(5);\n  });\n\n  it('test_06: returns 21 for n=8', () => {\n    const result = fibonacci(8);\n    expect(result).toBe(21);\n  });\n});\n",
    "src/structy/linked-list/get-node-value.ts": "export class Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nconst a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\na.next = b;\nb.next = c;\nc.next = d;\n\n/**\n * Time: O(n)\n * Space: O(1)\n */\nexport const getNodeValue = <T>(head: Node<T> | null, index: number): null | T => {\n  console.log(head?.val, index);\n  if (head === null) {\n    return head;\n  }\n  if (index === 0) {\n    return head.val;\n  }\n  return getNodeValue(head.next, index - 1);\n};\n\n/**\n * Time: O(n)\n * Space: O(n)\n */\nexport const getNodeValueIterative = <T>(head: Node<T> | null, index: number): null | T => {\n  let current = head;\n  let counter = 0;\n  while (current !== null) {\n    if (counter === index) {\n      return current.val;\n    }\n    counter += 1;\n    current = current.next;\n  }\n  return null;\n};\n\nconsole.log(getNodeValueIterative(a, 2));\n",
    "src/structy/linked-list/linked-list-find.spec.ts": "import { describe, it, expect } from 'vitest';\nimport { linkedListFindRecursive as linkedListFind } from './linked-list-find.js';\n\nclass Node<T> {\n  val: T;\n  next: Node<T> | null;\n\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\ndescribe('linkedListFind', () => {\n  it('test_00: should find a value in the middle of a linked list', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n\n    a.next = b;\n    b.next = c;\n    c.next = d;\n\n    // a -> b -> c -> d\n    expect(linkedListFind(a, 'c')).toBe(true);\n  });\n\n  it('test_01: should find a value at the end of a linked list', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n\n    a.next = b;\n    b.next = c;\n    c.next = d;\n\n    // a -> b -> c -> d\n    expect(linkedListFind(a, 'd')).toBe(true);\n  });\n\n  it('test_02: should return false when value is not in the linked list', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n\n    a.next = b;\n    b.next = c;\n    c.next = d;\n\n    // a -> b -> c -> d\n    expect(linkedListFind(a, 'q')).toBe(false);\n  });\n\n  it('test_03: should find a string value in a two-node linked list', () => {\n    const node1 = new Node('jason');\n    const node2 = new Node('leneli');\n\n    node1.next = node2;\n\n    // jason -> leneli\n    expect(linkedListFind(node1, 'jason')).toBe(true);\n  });\n\n  it('test_04: should find a number value in a single-node linked list', () => {\n    const node1 = new Node(42);\n\n    // 42\n    expect(linkedListFind(node1, 42)).toBe(true);\n  });\n\n  it('test_05: should return false when searching for a different number in a single-node linked list', () => {\n    const node1 = new Node(42);\n\n    // 42\n    expect(linkedListFind(node1, 100)).toBe(false);\n  });\n});\n",
    "src/structy/linked-list/get-node-value.spec.ts": "import { describe, it, expect } from 'vitest';\nimport { getNodeValue, Node } from './get-node-value.js';\n\ndescribe('getNodeValue', () => {\n  it('test_00 - should return the value at index 2 from a 4-node list', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n    a.next = b;\n    b.next = c;\n    c.next = d;\n    // a -> b -> c -> d\n    expect(getNodeValue(a, 2)).toBe('c'); // 'c'\n  });\n\n  it('test_01 - should return the value at the last index (3) from a 4-node list', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n    a.next = b;\n    b.next = c;\n    c.next = d;\n    // a -> b -> c -> d\n    expect(getNodeValue(a, 3)).toBe('d'); // 'd'\n  });\n\n  it('test_02 - should return null when index is out of bounds (7 is beyond list length)', () => {\n    const a = new Node('a');\n    const b = new Node('b');\n    const c = new Node('c');\n    const d = new Node('d');\n    a.next = b;\n    b.next = c;\n    c.next = d;\n    // a -> b -> c -> d\n    expect(getNodeValue(a, 7)).toBe(null); // null\n  });\n\n  it(\"test_03 - should return the first node's value (index 0) from a 2-node list\", () => {\n    const node1 = new Node('banana');\n    const node2 = new Node('mango');\n    node1.next = node2;\n    // banana -> mango\n    expect(getNodeValue(node1, 0)).toBe('banana'); // 'banana'\n  });\n\n  it(\"test_04 - should return the second node's value (index 1) from a 2-node list\", () => {\n    const node1 = new Node('banana');\n    const node2 = new Node('mango');\n    node1.next = node2;\n    // banana -> mango\n    expect(getNodeValue(node1, 1)).toBe('mango'); // 'mango'\n  });\n});\n",
    "src/structy/linked-list/linked-list-find.ts": "class Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n/**\n * Check if a certain value exists in a linked list\n *\n * Time: O(n)\n * Space: O(n)\n */\nexport const linkedListFind = <T>(head: Node<T> | null, target: T): boolean => {\n  let current: Node<T> | null = head;\n\n  while (current !== null) {\n    if (target === current?.val) {\n      return true;\n    }\n    current = current.next;\n  }\n  return false;\n};\n\nexport const linkedListFindRecursive = <T>(head: Node<T> | null, target: T): boolean => {\n  if (head === null) {\n    return false;\n  }\n\n  if (head.val === target) {\n    return true;\n  }\n\n  return linkedListFindRecursive(head.next, target);\n};\n",
    "src/structy/linked-list/linked-list-warm-up-exercise.ts": "class Node<T> {\n  val: T;\n  next: null | Node<T>;\n  constructor(val: T) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nconst a = new Node('A');\nconst b = new Node('B');\nconst c = new Node('C');\nconst d = new Node('D');\n\na.next = b;\nb.next = c;\nc.next = d;\n\n// A -> B -> C -> D -> NULL\n\nconst printLinkedList = <T>(head: Node<T>) => {\n  let current: Node<T> | null = head;\n  while (current !== null) {\n    console.log(current.val);\n    current = current.next;\n  }\n};\n\nprintLinkedList(a);\n\nconst printLinkedListRecursive = <T>(head: Node<T> | null) => {\n  if (head === null) {\n    return;\n  }\n\n  console.log(head.val);\n  printLinkedListRecursive(head.next);\n};\n\nprintLinkedListRecursive(a);\n",
    "dist/structy/fizz-buzz.js.map": "{\"version\":3,\"file\":\"fizz-buzz.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/fizz-buzz.ts\"],\"names\":[],\"mappings\":\"AAAA;;;GAGG;AAEH,MAAM,QAAQ,GAAG,CAAC,CAAS,EAAE,EAAE;IAC7B,MAAM,UAAU,GAAG,EAAE,CAAC;IAEtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAClC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;YAC/B,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1B,CAAC;aAAM,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;YACvB,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1B,CAAC;aAAM,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;YACvB,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1B,CAAC;aAAM,CAAC;YACN,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACrB,CAAC;IACH,CAAC;IACD,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC\"}",
    "dist/structy/max-value.js": "const maxValue = (nums) => {\n    let maximum = -Infinity;\n    for (const num of nums) {\n        if (num > maximum) {\n            maximum = num;\n        }\n    }\n    return maximum;\n};\nconsole.log(maxValue([10, 12, 15, 5]));\nexport {};\n//# sourceMappingURL=max-value.js.map",
    "dist/structy/big-o-samples.js": "/**\n * This will happen in constant time\n */\nconst greet = () => {\n    const greeting = 'hello';\n    console.log(greeting);\n};\ngreet();\n/**\n * This will also happen in constant time since object keys are hashes\n */\nconst existsInObject = (object, keyName) => {\n    return keyName in object;\n};\nconsole.log(existsInObject({ a: 'test' }, 'a'));\n/**\n * Time: O(n) Since the whole array could potentially require a pass to find a specific value.\n * Space: O(1)\n */\nconst existsInArray = (arr, value) => {\n    return arr.includes(value);\n};\nconsole.log(existsInArray(['test'], 'test'));\n/**\n * This will also happen in constant time O(n)\n */\nconst sumUsingFor = (arr) => {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i += 1) {\n        sum += arr[i];\n    }\n    return sum;\n};\nconsole.log(`Sum of array is ${sumUsingFor([1, 1, 1, 10, 10])}`);\n/** Time: O(n)\n *  Space: O(n) Since the range array grows with the size of n\n */\nconst range = (n) => {\n    const range = [];\n    for (let i = 1; i < n; i += 1) {\n        range.push(i); // Constant time operation will not add additional complexity\n    }\n    return range;\n};\nconsole.log('Range', range(10));\n/** Time: O(n^2) Since all the items of the array needs to be rearranged for each iteration of n\n *  Space: O(n) Since the range array grows with the size of n. It is not n^2 since it will not grow\n *              with the additional iterations made by the function.\n */\nconst reversedRange = (n) => {\n    const range = [];\n    for (let i = 1; i < n; i += 1) {\n        /**\n         * Insert value in front of an array. Since the value is inserted in the front of the array this\n         * will be an n operation. What really happens is that when the item is added in front all the\n         * other values has to be pushed one step in the array thus requiring an operation for each item\n         * in the array.\n         */\n        range.unshift(i);\n    }\n    return range;\n};\nconsole.log('Range', reversedRange(10));\n/**\n * Time: O(n^2) since the inner for loop will run for each other for loop\n * Space: O(1) since we are not creating any additional data structures\n */\nconst printPairs = (str) => {\n    for (let i = 0; i < str.length; i += 1) {\n        for (let j = 0; j < str.length; j += 1) {\n            console.log(`${str[i]} ${str[j]}`);\n        }\n    }\n    /** This will not add extra complexity since this is O(n) which is less complex than 0(n^2) */\n    for (let i = 0; i < str.length; i += 1) {\n        console.log(`${str[i]}`);\n    }\n};\nprintPairs('test');\nexport {};\n//# sourceMappingURL=big-o-samples.js.map",
    "dist/structy/anagrams.js.map": "{\"version\":3,\"file\":\"anagrams.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/anagrams.ts\"],\"names\":[],\"mappings\":\"AAAA;;;GAGG;AACH,MAAM,QAAQ,GAAG,CAAC,IAAY,EAAE,IAAY,EAAE,EAAE;IAC9C,MAAM,YAAY,GAA2B,EAAE,CAAC;IAEhD,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE,CAAC;QACxB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YACxB,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACzB,CAAC;aAAM,CAAC;YACN,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,CAAC;IACH,CAAC;IAED,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE,CAAC;QACxB,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YACvB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,CAAC;aAAM,CAAC;YACN,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IAED,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC;IAExE,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC\"}",
    "dist/structy/longest-word.js": "const longestWord = (sentence) => {\n    let longest = '';\n    const words = sentence.split(' ');\n    for (const word of words) {\n        if (word.length > longest.length) {\n            longest = word;\n        }\n    }\n    return longest;\n};\nconsole.info(longestWord('Testar att skriva lite gran'));\nexport {};\n//# sourceMappingURL=longest-word.js.map",
    "dist/structy/big-o-samples.js.map": "{\"version\":3,\"file\":\"big-o-samples.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/big-o-samples.ts\"],\"names\":[],\"mappings\":\"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\"}",
    "dist/structy/pairs.js.map": "{\"version\":3,\"file\":\"pairs.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/pairs.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;GASG;AACH,MAAM,KAAK,GAAG,CAAC,QAAkB,EAAE,EAAE;IACnC,MAAM,YAAY,GAAe,EAAE,CAAC;IACpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;YAChD,YAAY,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChD,CAAC;IACH,CAAC;IACD,OAAO,YAAY,CAAC;AACtB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/structy/hashing/all-unique.js": "/**\n * Time: O(n)\n * Space: O(n)\n */\nexport const allUnique = (items) => {\n    const uniqueItems = new Set(items);\n    return uniqueItems.size === items.length;\n};\n//# sourceMappingURL=all-unique.js.map",
    "dist/structy/hashing/all-unique.spec.js.map": "{\"version\":3,\"file\":\"all-unique.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/all-unique.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAE5C,QAAQ,CAAC,WAAW,EAAE,GAAG,EAAE;IACzB,EAAE,CAAC,iDAAiD,EAAE,GAAG,EAAE;QACzD,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;QAC/C,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,kDAAkD,EAAE,GAAG,EAAE;QAC1D,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;QACzD,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8CAA8C,EAAE,GAAG,EAAE;QACtD,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC;QACvE,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4CAA4C,EAAE,GAAG,EAAE;QACpD,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;QAChD,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,wDAAwD,EAAE,GAAG,EAAE;QAChE,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;QACzD,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/structy/hashing/test.js": "const test = new Set(['a', 'b', 'c']);\nconsole.log(test.keys());\nexport {};\n//# sourceMappingURL=test.js.map",
    "dist/structy/hashing/test.js.map": "{\"version\":3,\"file\":\"test.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/test.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;AAEtC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC\"}",
    "dist/structy/hashing/most-frequent-char.js": "/**\n * Write a function, mostFrequentChar, that takes in a string as an argument. The function should\n * return the most frequent character of the string. If there are ties, return the character that\n * appears earlier in the string.\n *\n * You can assume that the input string is non-empty.\n */\nconst mostFrequentChar = (str) => {\n    const charCounts = {};\n    for (const char of str) {\n        if (!charCounts[char]) {\n            charCounts[char] = 1;\n        }\n        else {\n            charCounts[char] += 1;\n        }\n    }\n    // This works but can cause ordering issues\n    // for (const [key, value] of Object.entries(charCounts)) {\n    //   if (value > highestCount[1]) {\n    //     highestCount = [key, value];\n    //   }\n    // }\n    let highestChar = null;\n    for (let char of str) {\n        if (highestChar === null || charCounts[char] > charCounts[highestChar]) {\n            highestChar = char;\n        }\n    }\n    return highestChar;\n};\nconsole.log(mostFrequentChar('asdfasdffjjjddaaaaaaaa'));\nexport {};\n//# sourceMappingURL=most-frequent-char.js.map",
    "dist/structy/most-frequent-char.js.map": "{\"version\":3,\"file\":\"most-frequent-char.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/most-frequent-char.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;GAMG;AACH,MAAM,gBAAgB,GAAG,CAAC,GAAW,EAAE,EAAE;IACvC,MAAM,UAAU,GAA2B,EAAE,CAAC;IAC9C,KAAK,MAAM,IAAI,IAAI,GAAG,EAAE,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC;YACtB,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC;aAAM,CAAC;YACN,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxB,CAAC;IACH,CAAC;IAED,2CAA2C;IAC3C,2DAA2D;IAC3D,mCAAmC;IACnC,mCAAmC;IACnC,MAAM;IACN,IAAI;IAEJ,IAAI,WAAW,GAAkB,IAAI,CAAC;IACtC,KAAK,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;QACrB,IAAI,WAAW,KAAK,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC;YACvE,WAAW,GAAG,IAAI,CAAC;QACrB,CAAC;IACH,CAAC;IAED,OAAO,WAAW,CAAC;AACrB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,wBAAwB,CAAC,CAAC,CAAC\"}",
    "dist/structy/is-prime.js": "/**\n * Can only be divisible by one or itself.\n *\n * We can check if a number is divisible by another one by using modulus, like so:\n *\n * ```typescript\n * possiblePrime % 2 === 0 // possiblePrime is evenly divisible by 2\n * ```\n *\n * There is one caveat which is that we need to handle the case where the users passes in an\n * argument of 1 which can never be a prime number. We can handle this by simply returning early\n * from the function in this case\n *\n * @param possiblePrime  Possible prime number.\n */\nconst isPrime = (possiblePrime) => {\n    if (possiblePrime === 1) {\n        return false;\n    }\n    for (let i = 2; i < possiblePrime; i += 1) {\n        if (possiblePrime % i === 0) {\n            return false;\n        }\n    }\n    return true;\n};\nconsole.log(isPrime(7));\nexport {};\n//# sourceMappingURL=is-prime.js.map",
    "dist/structy/anagrams.js": "/**\n * Time: O(n+m)\n * Space: O(m)\n */\nconst anagrams = (str1, str2) => {\n    const anagramCount = {};\n    for (const char of str1) {\n        if (!anagramCount[char]) {\n            anagramCount[char] = 1;\n        }\n        else {\n            anagramCount[char] += 1;\n        }\n    }\n    for (const char of str2) {\n        if (anagramCount[char]) {\n            anagramCount[char] -= 1;\n        }\n        else {\n            return false;\n        }\n    }\n    const isEqual = Object.values(anagramCount).every(count => count === 0);\n    return isEqual;\n};\nconsole.log(anagrams('cchair', 'aicchr'));\nexport {};\n//# sourceMappingURL=anagrams.js.map",
    "dist/structy/most-frequent-char.js": "/**\n * Write a function, mostFrequentChar, that takes in a string as an argument. The function should\n * return the most frequent character of the string. If there are ties, return the character that\n * appears earlier in the string.\n *\n * You can assume that the input string is non-empty.\n */\nconst mostFrequentChar = str => {\n  const charCounts = {};\n  for (const char of str) {\n    if (!charCounts[char]) {\n      charCounts[char] = 1;\n    } else {\n      charCounts[char] += 1;\n    }\n  }\n  // This works but can cause ordering issues\n  // for (const [key, value] of Object.entries(charCounts)) {\n  //   if (value > highestCount[1]) {\n  //     highestCount = [key, value];\n  //   }\n  // }\n  let highestChar = null;\n  for (let char of str) {\n    if (highestChar === null || charCounts[char] > charCounts[highestChar]) {\n      highestChar = char;\n    }\n  }\n  return highestChar;\n};\nconsole.log(mostFrequentChar('asdfasdffjjjddaaaaaaaa'));\nexport {};\n//# sourceMappingURL=most-frequent-char.js.map\n",
    "dist/structy/fizz-buzz.js": "/**\n * * Time: O(n)\n * * Space: O(n)\n */\nconst fizzBuzz = (n) => {\n    const fizzBuzzes = [];\n    for (let i = 1; i < n + 1; i += 1) {\n        if (i % 3 === 0 && i % 5 === 0) {\n            fizzBuzzes.push('fizz');\n        }\n        else if (i % 3 === 0) {\n            fizzBuzzes.push('fizz');\n        }\n        else if (i % 5 === 0) {\n            fizzBuzzes.push('buzz');\n        }\n        else {\n            fizzBuzzes.push(i);\n        }\n    }\n    return fizzBuzzes;\n};\nconsole.log(fizzBuzz(16));\nexport {};\n//# sourceMappingURL=fizz-buzz.js.map",
    "dist/structy/max-value.js.map": "{\"version\":3,\"file\":\"max-value.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/max-value.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,QAAQ,GAAG,CAAC,IAAc,EAAE,EAAE;IAClC,IAAI,OAAO,GAAG,CAAC,QAAQ,CAAC;IAExB,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,IAAI,GAAG,GAAG,OAAO,EAAE,CAAC;YAClB,OAAO,GAAG,GAAG,CAAC;QAChB,CAAC;IACH,CAAC;IACD,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/structy/is-prime.js.map": "{\"version\":3,\"file\":\"is-prime.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/is-prime.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;;;;;;GAcG;AACH,MAAM,OAAO,GAAG,CAAC,aAAqB,EAAE,EAAE;IACxC,IAAI,aAAa,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC1C,IAAI,aAAa,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;YAC5B,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/structy/pairs.js": "/**\n *\n * Write a function, pairs, that takes in an array as an argument. The function should return an\n * array containing all unique pairs of elements.\n *\n * You may return the pairs in any order and the order of elements within a single pair does not\n * matter.You can assume that the input array contains unique elements.\n *\n * @see file://./README.md#pairs\n */\nconst pairs = (elements) => {\n    const elementPairs = [];\n    for (let i = 0; i < elements.length; i += 1) {\n        for (let j = i + 1; j < elements.length; j += 1) {\n            elementPairs.push([elements[i], elements[j]]);\n        }\n    }\n    return elementPairs;\n};\nconsole.log(pairs(['cherry', 'cranberry', 'banana', 'blueberry', 'lime', 'papaya']));\nexport {};\n//# sourceMappingURL=pairs.js.map",
    "dist/structy/hashing/pair-product.js": "/**\n * @see file://./README.md#pair-product\n */\nconst pairProduct = (numbers, targetProduct) => {\n    const previous = {};\n    for (let i = 0; i < numbers.length; i += 1) {\n        const number = numbers[i];\n        const previousIndex = previous[targetProduct / number];\n        if (previousIndex) {\n            return [i, previousIndex];\n        }\n        previous[number] = i;\n    }\n};\nconsole.log(pairProduct([3, 2, 5, 4, 1], 8));\nexport {};\n//# sourceMappingURL=pair-product.js.map",
    "dist/structy/hashing/anagrams.spec.js.map": "{\"version\":3,\"file\":\"anagrams.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/anagrams.spec.ts\"],\"names\":[],\"mappings\":\"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\"}",
    "dist/structy/hashing/intersection-with-dupes.spec.js.map": "{\"version\":3,\"file\":\"intersection-with-dupes.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/intersection-with-dupes.spec.ts\"],\"names\":[],\"mappings\":\"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\"}",
    "dist/structy/hashing/intersection-with-dupes.js": "const countElementsInArray = (elements) => {\n    const elementCounts = {};\n    for (const element of elements) {\n        elementCounts[element] = (elementCounts[element] ?? 0) + 1;\n    }\n    return elementCounts;\n};\n/**\n * Time: O(n+m) cause both arrays has to be converted to a count hash map\n * Space: O(n+m) since we need a hashmap for both the arrays\n */\nexport const intersectionWithDupes = (a, b) => {\n    const aOccurrenceCount = countElementsInArray(a);\n    const bOccurrenceCount = countElementsInArray(b);\n    const result = [];\n    for (const element of Object.keys(aOccurrenceCount)) {\n        if (!(element in bOccurrenceCount)) {\n            continue;\n        }\n        const smallestCharCount = Math.min(aOccurrenceCount[element], bOccurrenceCount[element]);\n        for (let i = 0; i < smallestCharCount; i += 1) {\n            result.push(element);\n        }\n    }\n    return result;\n};\nconsole.log(intersectionWithDupes(['a', 'a'], ['a', 'a'])); // ['a',]\n//# sourceMappingURL=intersection-with-dupes.js.map",
    "dist/structy/hashing/intersection-with-dupes.js.map": "{\"version\":3,\"file\":\"intersection-with-dupes.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/intersection-with-dupes.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,oBAAoB,GAAG,CAAwB,QAAa,EAAqB,EAAE;IACvF,MAAM,aAAa,GAAsB,EAAuB,CAAC;IACjE,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;QAC/B,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IAC7D,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAC,CAAW,EAAE,CAAW,EAAE,EAAE;IAChE,MAAM,gBAAgB,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;IACjD,MAAM,gBAAgB,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;IACjD,MAAM,MAAM,GAAa,EAAE,CAAC;IAE5B,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC;QACpD,IAAI,CAAC,CAAC,OAAO,IAAI,gBAAgB,CAAC,EAAE,CAAC;YACnC,SAAS;QACX,CAAC;QACD,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC;QAEzF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACvB,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS\"}",
    "dist/structy/hashing/all-unique.spec.js": "import { describe, it, expect } from 'vitest';\nimport { allUnique } from './all-unique.js';\ndescribe('allUnique', () => {\n    it('test_00: returns true for all unique characters', () => {\n        const result = allUnique(['q', 'r', 's', 'a']);\n        expect(result).toBe(true);\n    });\n    it('test_01: returns false when there are duplicates', () => {\n        const result = allUnique(['q', 'r', 's', 'a', 'r', 'z']);\n        expect(result).toBe(false);\n    });\n    it('test_02: returns true for unique color names', () => {\n        const result = allUnique(['red', 'blue', 'yellow', 'green', 'orange']);\n        expect(result).toBe(true);\n    });\n    it('test_03: returns false for duplicate words', () => {\n        const result = allUnique(['cat', 'cat', 'dog']);\n        expect(result).toBe(false);\n    });\n    it('test_04: returns false for duplicate letters in autumn', () => {\n        const result = allUnique(['a', 'u', 't', 'u', 'm', 'n']);\n        expect(result).toBe(false);\n    });\n});\n//# sourceMappingURL=all-unique.spec.js.map",
    "dist/structy/hashing/pair-product.js.map": "{\"version\":3,\"file\":\"pair-product.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/pair-product.ts\"],\"names\":[],\"mappings\":\"AAAA;;GAEG;AACH,MAAM,WAAW,GAAG,CAAC,OAAiB,EAAE,aAAqB,EAAE,EAAE;IAC/D,MAAM,QAAQ,GAA2B,EAAE,CAAC;IAE5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC3C,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QAC1B,MAAM,aAAa,GAAG,QAAQ,CAAC,aAAa,GAAG,MAAM,CAAC,CAAC;QACvD,IAAI,aAAa,EAAE,CAAC;YAClB,OAAO,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;QAC5B,CAAC;QACD,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACvB,CAAC;AACH,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/structy/hashing/anagrams.js.map": "{\"version\":3,\"file\":\"anagrams.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/anagrams.ts\"],\"names\":[],\"mappings\":\"AAAA;;;GAGG;AACH,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,IAAY,EAAE,IAAY,EAAE,EAAE;IACrD,MAAM,YAAY,GAA2B,EAAE,CAAC;IAEhD,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE,CAAC;QACxB,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAC7E,CAAC;IAED,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE,CAAC;QACxB,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YACvB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,CAAC;aAAM,CAAC;YACN,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IAED,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC;IAExE,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC\"}",
    "dist/structy/hashing/intersection.js": "const intersection = (a, b) => {\n    const occurrences = new Set(a);\n    const result = [];\n    for (const num of new Set(b)) {\n        if (occurrences.has(num)) {\n            result.push(num);\n        }\n    }\n    return result;\n};\n/**\n * Time: O(a*b) cause we need to iterate over every combination of a and b\n * Space O(min(a,b)) cause the occupying space will be less then the two arrays\n */\nconst intersectionIterative = (a, b) => {\n    const intersection = new Set(); // Could also be an array but set deduplicates\n    for (const aNumber of a) {\n        for (const bNumber of b) {\n            if (aNumber === bNumber) {\n                intersection.add(aNumber);\n            }\n        }\n    }\n    return Array.from(intersection);\n};\nconsole.log(intersection([4, 2, 1, 6], [3, 6, 9, 2, 10]));\nconsole.log(intersectionIterative([4, 2, 1, 6], [3, 6, 9, 2, 10]));\nexport {};\n//# sourceMappingURL=intersection.js.map",
    "dist/structy/hashing/intersection-with-dupes.spec.js": "import { describe, it, expect } from 'vitest';\nimport { intersectionWithDupes } from './intersection-with-dupes.js';\ndescribe('intersectionWithDupes', () => {\n    it('test_00: returns duplicate \"b\" from both arrays', () => {\n        const result = intersectionWithDupes(['a', 'b', 'c', 'b'], ['x', 'y', 'b', 'b']);\n        expect(result).toEqual(expect.arrayContaining(['b', 'b']));\n        expect(result).toHaveLength(2);\n    });\n    it('test_01: returns intersection with correct duplicate count', () => {\n        const result = intersectionWithDupes(['q', 'b', 'm', 's', 's', 's'], ['s', 'm', 's']);\n        expect(result).toEqual(expect.arrayContaining(['m', 's', 's']));\n        expect(result).toHaveLength(3);\n    });\n    it('test_02: returns single \"r\" when second array has one', () => {\n        const result = intersectionWithDupes(['p', 'r', 'r', 'r'], ['r']);\n        expect(result).toEqual(expect.arrayContaining(['r']));\n        expect(result).toHaveLength(1);\n    });\n    it('test_03: returns single \"r\" when first array has one', () => {\n        const result = intersectionWithDupes(['r'], ['p', 'r', 'r', 'r']);\n        expect(result).toEqual(expect.arrayContaining(['r']));\n        expect(result).toHaveLength(1);\n    });\n    it('test_04: returns empty array for disjoint sets', () => {\n        const result = intersectionWithDupes(['t', 'v', 'u'], ['g', 'c', 'd', 'f']);\n        expect(result).toEqual([]);\n    });\n    it('test_05: returns limited by smaller array count', () => {\n        const result = intersectionWithDupes(['a', 'a', 'a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a']);\n        expect(result).toEqual(expect.arrayContaining(['a', 'a', 'a', 'a']));\n        expect(result).toHaveLength(4);\n    });\n    it('test_06: handles large arrays efficiently', () => {\n        const a = [];\n        const b = [];\n        for (let i = 0; i < 20000; i += 1) {\n            a.push(String(i));\n            b.push(String(i));\n        }\n        const result = intersectionWithDupes(a, b);\n        expect(result).toHaveLength(20000);\n    });\n});\n//# sourceMappingURL=intersection-with-dupes.spec.js.map",
    "dist/structy/hashing/exclusive-items.spec.js": "import { describe, it, expect } from 'vitest';\nimport { exclusiveItems } from './exclusive-items.js';\ndescribe('exclusiveItems', () => {\n    it('should return the symmetric difference of two arrays', () => {\n        const result = exclusiveItems([4, 2, 1, 6], [3, 6, 9, 2, 10]);\n        expect(result).toEqual(expect.arrayContaining([4, 1, 3, 9, 10]));\n    });\n    it('returns the unique value when second array is subset', () => {\n        const result = exclusiveItems([2, 4, 6], [4, 2]);\n        expect(result).toEqual([6]);\n    });\n    it('returns only values unique to the larger array', () => {\n        const result = exclusiveItems([4, 2, 1], [1, 2, 4, 6]);\n        expect(result).toEqual([6]);\n    });\n    it('handles disjoint arrays', () => {\n        const result = exclusiveItems([0, 1, 2], [10, 11]);\n        expect(result).toEqual([0, 1, 2, 10, 11]);\n    });\n    it('returns empty array for identical large arrays', () => {\n        const size = 60000;\n        const a = Array.from({ length: size }, (_, i) => i);\n        const b = Array.from({ length: size }, (_, i) => i);\n        const result = exclusiveItems(a, b);\n        expect(result).toEqual([]);\n    });\n});\n//# sourceMappingURL=exclusive-items.spec.js.map",
    "dist/structy/hashing/anagrams.spec.js": "import { describe, it, expect } from 'vitest';\nimport { anagrams } from './anagrams.js';\ndescribe('anagrams', () => {\n    it('test_00: returns true for restful and fluster', () => {\n        const result = anagrams('restful', 'fluster');\n        expect(result).toBe(true);\n    });\n    it('test_01: returns false for cats and tocs', () => {\n        const result = anagrams('cats', 'tocs');\n        expect(result).toBe(false);\n    });\n    it('test_02: returns true for monkeyswrite and newyorktimes', () => {\n        const result = anagrams('monkeyswrite', 'newyorktimes');\n        expect(result).toBe(true);\n    });\n    it('test_03: returns false for paper and reapa', () => {\n        const result = anagrams('paper', 'reapa');\n        expect(result).toBe(false);\n    });\n    it('test_04: returns true for elbow and below', () => {\n        const result = anagrams('elbow', 'below');\n        expect(result).toBe(true);\n    });\n    it('test_05: returns false for tax and taxi (different lengths)', () => {\n        const result = anagrams('tax', 'taxi');\n        expect(result).toBe(false);\n    });\n    it('test_06: returns false for taxi and tax (different lengths)', () => {\n        const result = anagrams('taxi', 'tax');\n        expect(result).toBe(false);\n    });\n    it('test_07: returns true for night and thing', () => {\n        const result = anagrams('night', 'thing');\n        expect(result).toBe(true);\n    });\n    it('test_08: returns false for abbc and aabc (different character counts)', () => {\n        const result = anagrams('abbc', 'aabc');\n        expect(result).toBe(false);\n    });\n    it('test_09: returns false for po and popp (different lengths)', () => {\n        const result = anagrams('po', 'popp');\n        expect(result).toBe(false);\n    });\n    it('test_10: returns false for pp and oo (different characters)', () => {\n        const result = anagrams('pp', 'oo');\n        expect(result).toBe(false);\n    });\n});\n//# sourceMappingURL=anagrams.spec.js.map",
    "dist/structy/hashing/most-frequent-char.js.map": "{\"version\":3,\"file\":\"most-frequent-char.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/most-frequent-char.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;GAMG;AACH,MAAM,gBAAgB,GAAG,CAAC,GAAW,EAAE,EAAE;IACvC,MAAM,UAAU,GAA2B,EAAE,CAAC;IAC9C,KAAK,MAAM,IAAI,IAAI,GAAG,EAAE,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC;YACtB,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC;aAAM,CAAC;YACN,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxB,CAAC;IACH,CAAC;IAED,2CAA2C;IAC3C,2DAA2D;IAC3D,mCAAmC;IACnC,mCAAmC;IACnC,MAAM;IACN,IAAI;IAEJ,IAAI,WAAW,GAAkB,IAAI,CAAC;IACtC,KAAK,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;QACrB,IAAI,WAAW,KAAK,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC;YACvE,WAAW,GAAG,IAAI,CAAC;QACrB,CAAC;IACH,CAAC;IAED,OAAO,WAAW,CAAC;AACrB,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,wBAAwB,CAAC,CAAC,CAAC\"}",
    "dist/structy/hashing/all-unique.js.map": "{\"version\":3,\"file\":\"all-unique.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/all-unique.ts\"],\"names\":[],\"mappings\":\"AAAA;;;GAGG;AACH,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,KAAe,EAAE,EAAE;IAC3C,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC;IAEnC,OAAO,WAAW,CAAC,IAAI,KAAK,KAAK,CAAC,MAAM,CAAC;AAC3C,CAAC,CAAC\"}",
    "dist/structy/hashing/exclusive-items.js.map": "{\"version\":3,\"file\":\"exclusive-items.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/exclusive-items.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,CAAW,EAAE,CAAW,EAAE,EAAE;IACzD,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3B,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3B,MAAM,mBAAmB,GAAG,IAAI,GAAG,EAAE,CAAC;IAEtC,KAAK,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC;QACpB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACtB,mBAAmB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC;IACH,CAAC;IAED,KAAK,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC;QACpB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACtB,mBAAmB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/B,CAAC;IACH,CAAC;IAED,OAAO,KAAK,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;AACzC,CAAC,CAAC\"}",
    "dist/structy/hashing/anagrams.js": "/**\n * Time: O(n+m)\n * Space: O(m)\n */\nexport const anagrams = (str1, str2) => {\n    const anagramCount = {};\n    for (const char of str1) {\n        !anagramCount[char] ? (anagramCount[char] = 1) : (anagramCount[char] += 1);\n    }\n    for (const char of str2) {\n        if (anagramCount[char]) {\n            anagramCount[char] -= 1;\n        }\n        else {\n            return false;\n        }\n    }\n    const isEqual = Object.values(anagramCount).every(count => count === 0);\n    return isEqual;\n};\nconsole.log(anagrams('cchair', 'aiccr'));\n//# sourceMappingURL=anagrams.js.map",
    "dist/structy/hashing/exclusive-items.js": "export const exclusiveItems = (a, b) => {\n    const uniqueA = new Set(a);\n    const uniqueB = new Set(b);\n    const symmetricDifference = new Set();\n    for (const num of a) {\n        if (!uniqueB.has(num)) {\n            symmetricDifference.add(num);\n        }\n    }\n    for (const num of b) {\n        if (!uniqueA.has(num)) {\n            symmetricDifference.add(num);\n        }\n    }\n    return Array.from(symmetricDifference);\n};\n//# sourceMappingURL=exclusive-items.js.map",
    "dist/structy/hashing/exclusive-items.spec.js.map": "{\"version\":3,\"file\":\"exclusive-items.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/exclusive-items.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,OAAO,EAAE,cAAc,EAAE,MAAM,sBAAsB,CAAC;AAEtD,QAAQ,CAAC,gBAAgB,EAAE,GAAG,EAAE;IAC9B,EAAE,CAAC,sDAAsD,EAAE,GAAG,EAAE;QAC9D,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;QAC9D,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,sDAAsD,EAAE,GAAG,EAAE;QAC9D,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACjD,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,gDAAgD,EAAE,GAAG,EAAE;QACxD,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACvD,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,yBAAyB,EAAE,GAAG,EAAE;QACjC,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QACnD,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,gDAAgD,EAAE,GAAG,EAAE;QACxD,MAAM,IAAI,GAAG,KAAK,CAAC;QACnB,MAAM,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACpD,MAAM,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACpD,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "dist/structy/hashing/intersection.js.map": "{\"version\":3,\"file\":\"intersection.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/hashing/intersection.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,YAAY,GAAG,CAAC,CAAW,EAAE,CAAW,EAAE,EAAE;IAChD,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;IAE/B,MAAM,MAAM,GAAa,EAAE,CAAC;IAC5B,KAAK,MAAM,GAAG,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;QAC7B,IAAI,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACzB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACnB,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,qBAAqB,GAAG,CAAC,CAAW,EAAE,CAAW,EAAE,EAAE;IACzD,MAAM,YAAY,GAAG,IAAI,GAAG,EAAE,CAAC,CAAC,8CAA8C;IAE9E,KAAK,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC;QACxB,KAAK,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC;YACxB,IAAI,OAAO,KAAK,OAAO,EAAE,CAAC;gBACxB,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAC5B,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AAClC,CAAC,CAAC;AAEF,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;AAE1D,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/structy/longest-word.js.map": "{\"version\":3,\"file\":\"longest-word.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/structy/longest-word.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,WAAW,GAAG,CAAC,QAAgB,EAAE,EAAE;IACvC,IAAI,OAAO,GAAG,EAAE,CAAC;IACjB,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAElC,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,IAAI,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;YACjC,OAAO,GAAG,IAAI,CAAC;QACjB,CAAC;IACH,CAAC;IACD,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,6BAA6B,CAAC,CAAC,CAAC\"}",
    "src/structy/is-prime.ts": "/**\n * Can only be divisible by one or itself.\n *\n * We can check if a number is divisible by another one by using modulus, like so:\n *\n * ```typescript\n * possiblePrime % 2 === 0 // possiblePrime is evenly divisible by 2\n * ```\n *\n * There is one caveat which is that we need to handle the case where the users passes in an\n * argument of 1 which can never be a prime number. We can handle this by simply returning early\n * from the function in this case\n *\n * @param possiblePrime  Possible prime number.\n */\nconst isPrime = (possiblePrime: number) => {\n  if (possiblePrime === 1) {\n    return false;\n  }\n\n  for (let i = 2; i < possiblePrime; i += 1) {\n    if (possiblePrime % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconsole.log(isPrime(7));\n",
    "src/structy/pairs.ts": "/**\n *\n * Write a function, pairs, that takes in an array as an argument. The function should return an\n * array containing all unique pairs of elements.\n *\n * You may return the pairs in any order and the order of elements within a single pair does not\n * matter.You can assume that the input array contains unique elements.\n *\n * @see file://./README.md#pairs\n */\nconst pairs = (elements: string[]) => {\n  const elementPairs: string[][] = [];\n  for (let i = 0; i < elements.length; i += 1) {\n    for (let j = i + 1; j < elements.length; j += 1) {\n      elementPairs.push([elements[i], elements[j]]);\n    }\n  }\n  return elementPairs;\n};\n\nconsole.log(pairs(['cherry', 'cranberry', 'banana', 'blueberry', 'lime', 'papaya']));\n",
    "src/structy/.gitignore": "*.mp4\n*.png\n*.mkv\n",
    "src/structy/fizz-buzz.ts": "/**\n * * Time: O(n)\n * * Space: O(n)\n */\n\nconst fizzBuzz = (n: number) => {\n  const fizzBuzzes = [];\n\n  for (let i = 1; i < n + 1; i += 1) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      fizzBuzzes.push('fizz');\n    } else if (i % 3 === 0) {\n      fizzBuzzes.push('fizz');\n    } else if (i % 5 === 0) {\n      fizzBuzzes.push('buzz');\n    } else {\n      fizzBuzzes.push(i);\n    }\n  }\n  return fizzBuzzes;\n};\n\nconsole.log(fizzBuzz(16));\n",
    "src/structy/README.md": "# DSA\n\n## How to Select Programming Paradigm\n\nUse functional programming when you're transforming complete datasets without early termination. Use imperative loops when you need early exit, mutable lookup tables, or searching—where the algorithm's nature is about control flow, not data transformation.\n\nUse imperative loops when you need early exit, mutable lookup tables, or searching—where the algorithm's nature is about control flow, not data transformation.\n\n## Big-0 Notion\n\n[Structy Big-O Notation Basics](https://www.structy.net/problems/big-o-basics)\n\n- Allows us to compare performance of algorithms\n- Does not rely upon environment (language, hardware)\n\n### Simplification Rules\n\n- Drop any constant factors\n- Drop any smaller terms in a sum\n\n### Overview\n\n![alt text](tech/Programming/structy/image-2.png)\n\n## Pairs\n\n[Structy Pairs Problem](https://www.structy.net/problems/pairs)\n\n[pairs.ts](pairs.ts)\n\n![alt text](tech/Programming/structy/image-3.png)\n\nWrite a function, pairs, that takes in an array as an argument. The function should return an array containing all unique pairs of elements.\n\nYou may return the pairs in any order and the order of elements within a single pair does not matter.\n\nYou can assume that the input array contains unique elements.\n\n## Hashing\n\nBy using hashing we can reduce complexity from 0(n^2) to O(n)\n\n## Check In\n",
    "src/structy/max-value.ts": "const maxValue = (nums: number[]) => {\n  let maximum = -Infinity;\n\n  for (const num of nums) {\n    if (num > maximum) {\n      maximum = num;\n    }\n  }\n  return maximum;\n};\n\nconsole.log(maxValue([10, 12, 15, 5]));\n",
    "dist/structy/linked-list/linked-list-values.spec.js.map": "{\"version\":3,\"file\":\"linked-list-values.spec.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/linked-list/linked-list-values.spec.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAE9C,MAAM,IAAI;IACR,GAAG,CAAI;IACP,IAAI,CAAiB;IACrB,YAAY,GAAM;QAChB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;CACF;AAED,OAAO,EAAE,gBAAgB,EAAE,MAAM,yBAAyB,CAAC;AAE3D,QAAQ,CAAC,kBAAkB,EAAE,GAAG,EAAE;IAChC,EAAE,CAAC,mEAAmE,EAAE,GAAG,EAAE;QAC3E,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QACxB,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QACxB,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QACxB,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QAExB,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;QACX,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;QACX,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;QAEX,mBAAmB;QACnB,MAAM,MAAM,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;QACnC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IAC/C,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,yDAAyD,EAAE,GAAG,EAAE;QACjE,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QACxB,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QAExB,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;QAEX,SAAS;QACT,MAAM,MAAM,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;QACnC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IACrC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4DAA4D,EAAE,GAAG,EAAE;QACpE,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QAExB,IAAI;QACJ,MAAM,MAAM,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;QACnC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAChC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,4CAA4C,EAAE,GAAG,EAAE;QACpD,MAAM,MAAM,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACtC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC\"}",
    "src/type-safe-pick.ts": "const isInArray = <T, A extends T>(item: T, array: readonly A[]): item is A =>\n  array.includes(item as A);\n\nexport function pick<O extends object, T extends keyof O>(obj: O, keys: T[]): Pick<O, T> {\n  const pickedObject = keys.reduce(\n    (acc, key) => {\n      if (obj[key] !== undefined) {\n        acc[key] = obj[key];\n      }\n      return acc;\n    },\n    {} as Pick<O, T>\n  );\n\n  return pickedObject;\n}\n\nexport function omit<O extends object, K extends keyof O>(obj: O, keys: K[]): Omit<O, K> {\n  const objKeys = Object.keys(obj) as K[];\n\n  return objKeys.reduce<Omit<O, K>>(\n    (result, key) => {\n      if (!isInArray(key, keys)) {\n        result[key] = obj[key];\n      }\n      return result;\n    },\n    {} as Omit<O, K>\n  );\n}\n\nArray.from(new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\n",
    "eslint.config.js": "import eslint from '@eslint/js';\nimport { defineConfig } from 'eslint/config';\nimport tseslint from 'typescript-eslint';\n\nexport default defineConfig(\n  {\n    ignores: ['dist/'],\n  },\n  {\n    files: ['**/*.js'],\n    languageOptions: {\n      globals: {\n        console: 'readonly',\n        process: 'readonly',\n      },\n    },\n  },\n  eslint.configs.recommended,\n  tseslint.configs.strict,\n  tseslint.configs.stylistic\n);\n",
    "dist/structy/linked-list/linked-list-values.js.map": "{\"version\":3,\"file\":\"linked-list-values.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/linked-list/linked-list-values.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,IAAI;IACR,GAAG,CAAI;IACP,IAAI,CAAiB;IACrB,YAAY,GAAM;QAChB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;CACF;AAED;;;;;GAKG;AACH,MAAM,CAAC,MAAM,gBAAgB,GAAG,CAAI,IAAoB,EAAO,EAAE;IAC/D,IAAI,OAAO,GAAG,IAAI,CAAC;IACnB,MAAM,MAAM,GAAQ,EAAE,CAAC;IACvB,OAAO,OAAO,KAAK,IAAI,EAAE,CAAC;QACxB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACzB,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;IACzB,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC\"}",
    "dist/structy/linked-list/generate-problems.js.map": "{\"version\":3,\"file\":\"generate-problems.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/linked-list/generate-problems.ts\"],\"names\":[],\"mappings\":\"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\"}",
    "dist/structy/linked-list/linked-list-values.js": "class Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n/**\n * Converts a linked list to an array\n *\n * Time: O(n)\n * Space: O(n)\n */\nexport const linkedListValues = (head) => {\n    let current = head;\n    const values = [];\n    while (current !== null) {\n        values.push(current.val);\n        current = current.next;\n    }\n    return values;\n};\n//# sourceMappingURL=linked-list-values.js.map",
    "dist/structy/linked-list/linked-list-warm-up-exercise.js": "class Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val;\n        this.next = null;\n    }\n}\nconst a = new Node('A');\nconst b = new Node('B');\nconst c = new Node('C');\nconst d = new Node('D');\na.next = b;\nb.next = c;\nc.next = d;\n// A -> B -> C -> D -> NULL\nconst printLinkedList = (head) => {\n    let current = head;\n    while (current !== null) {\n        console.log(current.val);\n        current = current.next;\n    }\n};\nprintLinkedList(a);\nconst printLinkedListRecursive = (head) => {\n    if (head === null) {\n        return;\n    }\n    console.log(head.val);\n    printLinkedListRecursive(head.next);\n};\nprintLinkedListRecursive(a);\nexport {};\n//# sourceMappingURL=linked-list-warm-up-exercise.js.map",
    "dist/structy/linked-list/generate-problems.js": "import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport yaml from 'js-yaml';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nconst execAsync = promisify(exec);\nconst __dirname = import.meta.dirname;\nasync function loadProblems() {\n    const filePath = path.join(__dirname, 'problems.yaml');\n    const fileContent = await fs.readFile(filePath, 'utf-8');\n    const data = yaml.load(fileContent);\n    if (!data.problems || !Array.isArray(data.problems)) {\n        throw new Error('Invalid problems.yaml structure: missing or invalid problems array');\n    }\n    return data;\n}\nfunction validateProblem(problem) {\n    return !!(problem.name && problem.functionName && problem.description);\n}\nasync function getProblems() {\n    const data = await loadProblems();\n    const validProblems = data.problems.filter(validateProblem);\n    if (validProblems.length !== data.problems.length) {\n        console.warn('Some problems failed validation and were skipped');\n    }\n    return validProblems;\n}\nasync function createProblemFileStructure(problem) {\n    const sourceFileContent = generateSourceFile(problem.description, problem.functionName);\n    const sourceFilePath = path.join(__dirname, `${problem.name}.ts`);\n    if (!existsSync(sourceFilePath)) {\n        fs.writeFile(sourceFilePath, sourceFileContent);\n    }\n    const specFileContent = '';\n    const specFilePath = path.join(__dirname, `${problem.name}.spec.ts`);\n    if (!existsSync(specFilePath)) {\n        fs.writeFile(specFilePath, specFileContent);\n    }\n    const solutionsFileContent = '';\n    const solutionsFilePath = path.join(__dirname, `${problem.name}-solution.js`);\n    if (!existsSync(solutionsFilePath)) {\n        fs.writeFile(solutionsFilePath, solutionsFileContent);\n    }\n    const approachFileName = `${problem.name}-approach.mp4`;\n    const approachFilePath = path.join(__dirname, approachFileName);\n    if (!existsSync(approachFilePath)) {\n        await downloadVideoFile(problem.approachUrl, approachFileName);\n    }\n    const walkthroughFileName = `${problem.name}-walkthrough.mp4`;\n    const walkthroughFilePath = path.join(__dirname, walkthroughFileName);\n    if (!existsSync(walkthroughFilePath)) {\n        await downloadVideoFile(problem.walkthroughUrl, walkthroughFileName);\n    }\n}\nconst sourceFileTemplate = `/**\n * {{description}}\n * \n * Time: O(?)\n * Space: O(?)\n */\nexport const {{functionName}} = (): void => {\n  // TODO: Implement\n};\n`;\nfunction generateSourceFile(description, functionName) {\n    return sourceFileTemplate\n        .replace('{{description}}', description)\n        .replace('{{functionName}}', functionName);\n}\nasync function downloadVideoFile(url, filename) {\n    try {\n        await execAsync(`yt-dlp -o \"${filename}\" \"${url}\"`);\n    }\n    catch (error) {\n        if (error instanceof Error && 'stderr' in error) {\n            console.error('Error while downloading video', { error: error.stderr });\n        }\n        else {\n            throw error;\n        }\n    }\n}\nasync function main() {\n    const problems = await getProblems();\n    const problemPromises = problems.map(problem => createProblemFileStructure(problem));\n    Promise.all(problemPromises);\n}\nawait main();\n//# sourceMappingURL=generate-problems.js.map",
    "dist/structy/linked-list/linked-list-warm-up-exercise.js.map": "{\"version\":3,\"file\":\"linked-list-warm-up-exercise.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/structy/linked-list/linked-list-warm-up-exercise.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,IAAI;IACR,GAAG,CAAM;IACT,IAAI,CAAc;IAClB,YAAY,GAAQ;QAClB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;CACF;AAED,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;AACxB,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;AACxB,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;AACxB,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC;AAExB,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;AACX,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;AACX,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;AAEX,2BAA2B;AAE3B,MAAM,eAAe,GAAG,CAAC,IAAU,EAAE,EAAE;IACrC,IAAI,OAAO,GAAgB,IAAI,CAAC;IAChC,OAAO,OAAO,KAAK,IAAI,EAAE,CAAC;QACxB,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACzB,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;IACzB,CAAC;AACH,CAAC,CAAC;AAEF,eAAe,CAAC,CAAC,CAAC,CAAC;AAEnB,MAAM,wBAAwB,GAAG,CAAC,IAAiB,EAAE,EAAE;IACrD,IAAI,IAAI,KAAK,IAAI,EAAE,CAAC;QAClB,OAAO;IACT,CAAC;IAED,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACtB,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACtC,CAAC,CAAC;AAEF,wBAAwB,CAAC,CAAC,CAAC,CAAC\"}",
    "dist/structy/linked-list/linked-list-values.spec.js": "import { describe, it, expect } from 'vitest';\nclass Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val;\n        this.next = null;\n    }\n}\nimport { linkedListValues } from './linked-list-values.js';\ndescribe('linkedListValues', () => {\n    it('test_00: returns array of values for linked list a -> b -> c -> d', () => {\n        const a = new Node('a');\n        const b = new Node('b');\n        const c = new Node('c');\n        const d = new Node('d');\n        a.next = b;\n        b.next = c;\n        c.next = d;\n        // a -> b -> c -> d\n        const result = linkedListValues(a);\n        expect(result).toEqual(['a', 'b', 'c', 'd']);\n    });\n    it('test_01: returns array of values for linked list x -> y', () => {\n        const x = new Node('x');\n        const y = new Node('y');\n        x.next = y;\n        // x -> y\n        const result = linkedListValues(x);\n        expect(result).toEqual(['x', 'y']);\n    });\n    it('test_02: returns array with single value for single node q', () => {\n        const q = new Node('q');\n        // q\n        const result = linkedListValues(q);\n        expect(result).toEqual(['q']);\n    });\n    it('test_03: returns empty array for null head', () => {\n        const result = linkedListValues(null);\n        expect(result).toEqual([]);\n    });\n});\n//# sourceMappingURL=linked-list-values.spec.js.map",
    "src/structy/hashing/exclusive-items.ts": "export const exclusiveItems = (a: number[], b: number[]) => {\n  const uniqueA = new Set(a);\n  const uniqueB = new Set(b);\n  const symmetricDifference = new Set();\n\n  for (const num of a) {\n    if (!uniqueB.has(num)) {\n      symmetricDifference.add(num);\n    }\n  }\n\n  for (const num of b) {\n    if (!uniqueA.has(num)) {\n      symmetricDifference.add(num);\n    }\n  }\n\n  return Array.from(symmetricDifference);\n};\n",
    "src/structy/hashing/pair-product.js": "/**\n * @see file://./README.md#pair-product\n */\nconst pairProduct = (numbers, targetProduct) => {\n  const previous = {};\n\n  for (let i = 0; i < numbers.length; i += 1) {\n    const number = numbers[i];\n    const previousIndex = previous[targetProduct / number];\n    if (previousIndex) {\n      return [i, previousIndex];\n    }\n    previous[number] = i;\n  }\n};\n\nconsole.log(pairProduct([3, 2, 5, 4, 1], 8));\n",
    "src/structy/hashing/anagrams.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { anagrams } from './anagrams.js';\n\ndescribe('anagrams', () => {\n  it('test_00: returns true for restful and fluster', () => {\n    const result = anagrams('restful', 'fluster');\n    expect(result).toBe(true);\n  });\n\n  it('test_01: returns false for cats and tocs', () => {\n    const result = anagrams('cats', 'tocs');\n    expect(result).toBe(false);\n  });\n\n  it('test_02: returns true for monkeyswrite and newyorktimes', () => {\n    const result = anagrams('monkeyswrite', 'newyorktimes');\n    expect(result).toBe(true);\n  });\n\n  it('test_03: returns false for paper and reapa', () => {\n    const result = anagrams('paper', 'reapa');\n    expect(result).toBe(false);\n  });\n\n  it('test_04: returns true for elbow and below', () => {\n    const result = anagrams('elbow', 'below');\n    expect(result).toBe(true);\n  });\n\n  it('test_05: returns false for tax and taxi (different lengths)', () => {\n    const result = anagrams('tax', 'taxi');\n    expect(result).toBe(false);\n  });\n\n  it('test_06: returns false for taxi and tax (different lengths)', () => {\n    const result = anagrams('taxi', 'tax');\n    expect(result).toBe(false);\n  });\n\n  it('test_07: returns true for night and thing', () => {\n    const result = anagrams('night', 'thing');\n    expect(result).toBe(true);\n  });\n\n  it('test_08: returns false for abbc and aabc (different character counts)', () => {\n    const result = anagrams('abbc', 'aabc');\n    expect(result).toBe(false);\n  });\n\n  it('test_09: returns false for po and popp (different lengths)', () => {\n    const result = anagrams('po', 'popp');\n    expect(result).toBe(false);\n  });\n\n  it('test_10: returns false for pp and oo (different characters)', () => {\n    const result = anagrams('pp', 'oo');\n    expect(result).toBe(false);\n  });\n});\n",
    "src/structy/hashing/anagrams.ts": "/**\n * Time: O(n+m)\n * Space: O(m)\n */\nexport const anagrams = (str1: string, str2: string) => {\n  const anagramCount: Record<string, number> = {};\n\n  for (const char of str1) {\n    !anagramCount[char] ? (anagramCount[char] = 1) : (anagramCount[char] += 1);\n  }\n\n  for (const char of str2) {\n    if (anagramCount[char]) {\n      anagramCount[char] -= 1;\n    } else {\n      return false;\n    }\n  }\n\n  const isEqual = Object.values(anagramCount).every(count => count === 0);\n\n  return isEqual;\n};\n\nconsole.log(anagrams('cchair', 'aiccr'));\n",
    "src/structy/hashing/all-unique.ts": "/**\n * Time: O(n)\n * Space: O(n)\n */\nexport const allUnique = (items: string[]) => {\n  const uniqueItems = new Set(items);\n\n  return uniqueItems.size === items.length;\n};\n",
    "src/structy/hashing/all-unique-sollution.js": "const allUnique = items => {\n  const uniqueItems = new Set(items);\n  return uniqueItems.size === items.length;\n};\n",
    "src/structy/hashing/intersection-with-dupes-sollution.js": "const intersectionWithDupes = (a, b) => {\n  const count1 = eleCount(a);\n  const count2 = eleCount(b);\n  const result = [];\n  for (let ele in count1) {\n    if (ele in count2) {\n      for (let i = 0; i < Math.min(count1[ele], count2[ele]); i += 1) {\n        result.push(ele);\n      }\n    }\n  }\n  return result;\n};\n\nconst eleCount = elements => {\n  const count = {};\n  for (let ele of elements) {\n    if (!(ele in count)) {\n      count[ele] = 0;\n    }\n    count[ele] += 1;\n  }\n  return count;\n};\n",
    "src/structy/hashing/most-frequent-char.ts": "/**\n * Write a function, mostFrequentChar, that takes in a string as an argument. The function should\n * return the most frequent character of the string. If there are ties, return the character that\n * appears earlier in the string.\n *\n * You can assume that the input string is non-empty.\n */\nconst mostFrequentChar = (str: string) => {\n  const charCounts: Record<string, number> = {};\n  for (const char of str) {\n    if (!charCounts[char]) {\n      charCounts[char] = 1;\n    } else {\n      charCounts[char] += 1;\n    }\n  }\n\n  // This works but can cause ordering issues\n  // for (const [key, value] of Object.entries(charCounts)) {\n  //   if (value > highestCount[1]) {\n  //     highestCount = [key, value];\n  //   }\n  // }\n\n  let highestChar: string | null = null;\n  for (let char of str) {\n    if (highestChar === null || charCounts[char] > charCounts[highestChar]) {\n      highestChar = char;\n    }\n  }\n\n  return highestChar;\n};\n\nconsole.log(mostFrequentChar('asdfasdffjjjddaaaaaaaa'));\n",
    "src/structy/hashing/intersection.js": "const intersection = (a, b) => {\n  const occurrences = new Set(a);\n\n  const result = [];\n  for (const num of new Set(b)) {\n    if (occurrences.has(num)) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n// Time: O(a*b) cause we need to iterate over every combination of a and b\n// Space: O(min(a,b)) cause the occupying space will be less than the two arrays\nconst intersectionIterative = (a, b) => {\n  const intersection = new Set(); // Could also be an array but set deduplicates\n\n  for (const aNumber of a) {\n    for (const bNumber of b) {\n      if (aNumber === bNumber) {\n        intersection.add(aNumber);\n      }\n    }\n  }\n  return Array.from(intersection);\n};\n\nconsole.log(intersection([4, 2, 1, 6], [3, 6, 9, 2, 10]));\n\nconsole.log(intersectionIterative([4, 2, 1, 6], [3, 6, 9, 2, 10]));\n",
    "src/structy/hashing/README.md": "# Hashing\n\n## anagrams\n\n## Pair Product\n\n[Pair Product Structy](https://www.structy.net/problems/pair-product)\n\n[pair-product.ts](pair-product.ts)\n\n### Instructions\n\nWrite a function, pairProduct, that takes in an array and a target product as arguments. The function should return an array containing a pair of indices whose elements multiply to the given target. The indices returned must be unique.\n\nBe sure to return the indices, not the elements themselves.\n\nThere is guaranteed to be one such pair whose product is the target.\n\n### Thoughts\n\nVery similar to the pair problems only thing to remember is that you device to figure out what the corresponding product is.\n\n## Intersection\n\n[intersection.ts](intersection.ts)\n\n### Instructions\n\nWrite a function, intersection, that takes in two arrays, a,b, as arguments. The function should return a new array containing elements that are in both of the two arrays.\n\nYou may assume that each input array does not contain duplicate elements.\n\n### Thoughts\n\nUsing some form of hash structure seam obvious for this. Initially I used a hashmap not thinking of a Set but the set does make more sense since I am only interested in storing one value. and the set also removes duplicates.\n\nI also implemented the O(n) version which uses multiple for loops to compare every item in both of the arrays to each other. This is however very inefficient interested in storing one value. and the set also removes duplicates.\n\nI also implemented the O(n) version which uses multiple for loops to compare every item in both of the arrays to each other. This is however very inefficient.\n\n## exclusive items\n\nWrite a function, exclusiveItems, that takes in two arrays, a,b, as arguments. The function should return a new array containing elements that are in either array but not both arrays.\n\nYou may assume that each input array does not contain duplicate elements.\n\n### Approach\n\n[video](exclusive-items-approach.mp4)\n\n1. Convert both arrays into sets\n2. Iterate through both of them and ensure that each item is not in the set representation.\n3. Add those items into a third set.\n\n[exclusive-items.ts](exclusive-items.ts)\n\n## all unique\n\nWrite a function, allUnique, that takes in an array. The function should return a boolean indicating whether or not the array contains unique items.\n\n### Approach\n\n[video](all-unique-approach.mp4)\n\n![image.png](/src/structy/hashing/image.png)\n\nThis is actually very simply since the set by default deduplicates an array. So it is just about converting the array to a set and comparing the length of it to the length of the array.\n\n### Lessons Learned\n\n- You can get the length of a set using `set.size()`\n\n## intersection with dupes\n\nWrite a function, intersectionWithDupes, that takes in two arrays, a,b, as arguments. The function should return a new array containing elements that are common to both input arrays. The elements in the result should appear as many times as they occur in both input arrays. You can return the result in any order.\n\n### Approach\n\n[video](intersection-with-dupes-approach.mp4) This will require a counter hash map since we need to keep track of the amount of duplicates in each array. The result should contain the lowest count of a char in the counter hashmaps\n\n### Walkthrough\n\n[video](intersection-with-dupes-walkthrough.mp4)  \n[text](intersection-with-dupes.ts)\n\n### Lessons Learned\n\n- `Math.min()` can be used to get the lowest of two values\n\n## hashing wrap up\n\n[video](hashing-wrap-up.mp4)\n",
    "src/structy/hashing/intersection-with-dupes.ts": "const countElementsInArray = <T extends PropertyKey>(elements: T[]): Record<T, number> => {\n  const elementCounts: Record<T, number> = {} as Record<T, number>;\n  for (const element of elements) {\n    elementCounts[element] = (elementCounts[element] ?? 0) + 1;\n  }\n  return elementCounts;\n};\n\n/**\n * Time: O(n+m) cause both arrays has to be converted to a count hash map\n * Space: O(n+m) since we need a hashmap for both the arrays\n */\nexport const intersectionWithDupes = (a: string[], b: string[]) => {\n  const aOccurrenceCount = countElementsInArray(a);\n  const bOccurrenceCount = countElementsInArray(b);\n  const result: string[] = [];\n\n  for (const element of Object.keys(aOccurrenceCount)) {\n    if (!(element in bOccurrenceCount)) {\n      continue;\n    }\n    const smallestCharCount = Math.min(aOccurrenceCount[element], bOccurrenceCount[element]);\n\n  \n    for (let i = 0; i < smallestCharCount; i += 1) {\n      result.push(element);\n    }\n  }\n  return result;\n};\n\nconsole.log(intersectionWithDupes(['a', 'a'], ['a', 'a'])); // ['a',]\n",
    "src/structy/hashing/pair-product.ts": "/**\n * @see file://./README.md#pair-product\n */\nconst pairProduct = (numbers: number[], targetProduct: number) => {\n  const previous: Record<number, number> = {};\n\n  for (let i = 0; i < numbers.length; i += 1) {\n    const number = numbers[i];\n    const previousIndex = previous[targetProduct / number];\n    if (previousIndex) {\n      return [i, previousIndex];\n    }\n    previous[number] = i;\n  }\n};\n\nconsole.log(pairProduct([3, 2, 5, 4, 1], 8));\n",
    "src/structy/hashing/all-unique.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { allUnique } from './all-unique.js';\n\ndescribe('allUnique', () => {\n  it('test_00: returns true for all unique characters', () => {\n    const result = allUnique(['q', 'r', 's', 'a']);\n    expect(result).toBe(true);\n  });\n\n  it('test_01: returns false when there are duplicates', () => {\n    const result = allUnique(['q', 'r', 's', 'a', 'r', 'z']);\n    expect(result).toBe(false);\n  });\n\n  it('test_02: returns true for unique color names', () => {\n    const result = allUnique(['red', 'blue', 'yellow', 'green', 'orange']);\n    expect(result).toBe(true);\n  });\n\n  it('test_03: returns false for duplicate words', () => {\n    const result = allUnique(['cat', 'cat', 'dog']);\n    expect(result).toBe(false);\n  });\n\n  it('test_04: returns false for duplicate letters in autumn', () => {\n    const result = allUnique(['a', 'u', 't', 'u', 'm', 'n']);\n    expect(result).toBe(false);\n  });\n});\n",
    "src/structy/hashing/intersection-with-dupes.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { intersectionWithDupes } from './intersection-with-dupes.js';\n\ndescribe('intersectionWithDupes', () => {\n  it('test_00: returns duplicate \"b\" from both arrays', () => {\n    const result = intersectionWithDupes(['a', 'b', 'c', 'b'], ['x', 'y', 'b', 'b']);\n    expect(result).toEqual(expect.arrayContaining(['b', 'b']));\n    expect(result).toHaveLength(2);\n  });\n\n  it('test_01: returns intersection with correct duplicate count', () => {\n    const result = intersectionWithDupes(['q', 'b', 'm', 's', 's', 's'], ['s', 'm', 's']);\n    expect(result).toEqual(expect.arrayContaining(['m', 's', 's']));\n    expect(result).toHaveLength(3);\n  });\n\n  it('test_02: returns single \"r\" when second array has one', () => {\n    const result = intersectionWithDupes(['p', 'r', 'r', 'r'], ['r']);\n    expect(result).toEqual(expect.arrayContaining(['r']));\n    expect(result).toHaveLength(1);\n  });\n\n  it('test_03: returns single \"r\" when first array has one', () => {\n    const result = intersectionWithDupes(['r'], ['p', 'r', 'r', 'r']);\n    expect(result).toEqual(expect.arrayContaining(['r']));\n    expect(result).toHaveLength(1);\n  });\n\n  it('test_04: returns empty array for disjoint sets', () => {\n    const result = intersectionWithDupes(['t', 'v', 'u'], ['g', 'c', 'd', 'f']);\n    expect(result).toEqual([]);\n  });\n\n  it('test_05: returns limited by smaller array count', () => {\n    const result = intersectionWithDupes(['a', 'a', 'a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a']);\n    expect(result).toEqual(expect.arrayContaining(['a', 'a', 'a', 'a']));\n    expect(result).toHaveLength(4);\n  });\n\n  it('test_06: handles large arrays efficiently', () => {\n    const a: string[] = [];\n    const b: string[] = [];\n    for (let i = 0; i < 20000; i += 1) {\n      a.push(String(i));\n      b.push(String(i));\n    }\n    const result = intersectionWithDupes(a, b);\n    expect(result).toHaveLength(20000);\n  });\n});\n",
    "src/structy/hashing/intersection.ts": "const intersection = (a: number[], b: number[]) => {\n  const occurrences = new Set(a);\n\n  const result: number[] = [];\n  for (const num of new Set(b)) {\n    if (occurrences.has(num)) {\n      result.push(num);\n    }\n  }\n  return result;\n};\n\n/**\n * Time: O(a*b) cause we need to iterate over every combination of a and b\n * Space O(min(a,b)) cause the occupying space will be less then the two arrays\n */\nconst intersectionIterative = (a: number[], b: number[]) => {\n  const intersection = new Set(); // Could also be an array but set deduplicates\n\n  for (const aNumber of a) {\n    for (const bNumber of b) {\n      if (aNumber === bNumber) {\n        intersection.add(aNumber);\n      }\n    }\n  }\n  return Array.from(intersection);\n};\n\nconsole.log(intersection([4, 2, 1, 6], [3, 6, 9, 2, 10]));\n\nconsole.log(intersectionIterative([4, 2, 1, 6], [3, 6, 9, 2, 10]));\n",
    "src/structy/hashing/exclusive-items.spec.ts": "import { describe, it, expect } from 'vitest';\n\nimport { exclusiveItems } from './exclusive-items.js';\n\ndescribe('exclusiveItems', () => {\n  it('should return the symmetric difference of two arrays', () => {\n    const result = exclusiveItems([4, 2, 1, 6], [3, 6, 9, 2, 10]);\n    expect(result).toEqual(expect.arrayContaining([4, 1, 3, 9, 10]));\n  });\n\n  it('returns the unique value when second array is subset', () => {\n    const result = exclusiveItems([2, 4, 6], [4, 2]);\n    expect(result).toEqual([6]);\n  });\n\n  it('returns only values unique to the larger array', () => {\n    const result = exclusiveItems([4, 2, 1], [1, 2, 4, 6]);\n    expect(result).toEqual([6]);\n  });\n\n  it('handles disjoint arrays', () => {\n    const result = exclusiveItems([0, 1, 2], [10, 11]);\n    expect(result).toEqual([0, 1, 2, 10, 11]);\n  });\n\n  it('returns empty array for identical large arrays', () => {\n    const size = 60000;\n    const a = Array.from({ length: size }, (_, i) => i);\n    const b = Array.from({ length: size }, (_, i) => i);\n    const result = exclusiveItems(a, b);\n    expect(result).toEqual([]);\n  });\n});\n"
  },
  "settings": {
    "compile": {
      "trigger": "auto"
    }
  },
  "description": "Small test projects"
},
      {
        newWindow: false,
      },
    );
  </script>
</body>
</html>
